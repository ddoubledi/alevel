<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>11-postgresql-crud - ALevel</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="db/11-postgresql-crud.html" class="active"><strong aria-hidden="true">1.</strong> 11-postgresql-crud</a></li><li class="chapter-item expanded "><a href="db/12-postgresql-join.html"><strong aria-hidden="true">2.</strong> 12-postgresql-join</a></li><li class="chapter-item expanded "><a href="db/13-postgresql-acid-normalization.html"><strong aria-hidden="true">3.</strong> 13-postgresql-acid-normalization</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ALevel</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="11-postgresql-crud.excalidraw.html">11-postgresql-crud.excalidraw</a></p>
<h1 id="posgresql-crud-таблиць-crud-записів"><a class="header" href="#posgresql-crud-таблиць-crud-записів">PosgreSQL. CRUD таблиць, CRUD записів.</a></h1>
<p><img src="attachments/Pasted%20image%2020240403093533.png" alt="" /></p>
<h1 id="Зміст"><a class="header" href="#Зміст">Зміст</a></h1>
<ul>
<li><a href="#%D0%A2%D0%B5%D0%BE%D1%80%D1%96%D1%8F-%D0%91%D0%94">Теорія БД</a>
<ul>
<li><a href="#%D0%91%D0%B0%D0%B7%D0%B0-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85"><strong>База даних</strong></a></li>
<li><a href="#%D0%92%D0%B8%D0%B4%D0%B8-%D0%B1%D0%B0%D0%B7-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85">Види баз даних.</a></li>
<li><a href="#%D0%A0%D0%B5%D0%BB%D1%8F%D1%86%D1%96%D0%B9%D0%BD%D0%B0-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C">Реляційна модель</a></li>
<li><a href="#postgresql">PostgreSQL</a></li>
</ul>
</li>
<li><a href="#sql">SQL</a>
<ul>
<li><a href="#%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81-sql">Синтаксис SQL</a></li>
</ul>
</li>
<li><a href="#%D0%9F%D1%96%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%BD%D1%8F-%D0%B4%D0%BE-%D0%A1%D0%A3%D0%91%D0%94-postgresql">Підключення до СУБД PostgreSQL</a>
<ul>
<li><a href="#%D0%A1%D1%82%D0%B2%D0%BE%D1%80%D0%B5%D0%BD%D0%BD%D1%8F-%D0%B1%D0%B0%D0%B7-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85-%D1%82%D0%B0-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8C">Створення баз даних та таблиць</a></li>
<li><a href="#%D0%A0%D0%B5%D0%B4%D0%B0%D0%B3%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%96">Редагування таблиці</a></li>
<li><a href="#%D0%92%D0%B8%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%96">Видалення таблиці</a></li>
</ul>
</li>
<li><a href="#crud-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85">CRUD даних</a>
<ul>
<li><a href="#create---%D0%B4%D0%BE%D0%B4%D0%B0%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85-insert">Create - додавання даних: INSERT</a></li>
<li><a href="#simple-insert">Simple insert</a></li>
<li><a href="#multiple-insert">Multiple insert</a></li>
<li><a href="#insert-from-select">Insert from select</a></li>
<li><a href="#read---%D0%B2%D0%B8%D0%B1%D1%96%D1%80%D0%BA%D0%B0-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85-select">Read - вибірка даних: SELECT</a></li>
<li><a href="#%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0-%D0%B7-select-%D1%82%D0%B0-insert">Практика з SELECT та INSERT</a></li>
<li><a href="#distinct">DISTINCT</a></li>
<li><a href="#where">WHERE</a></li>
<li><a href="#group-by">GROUP BY</a></li>
<li><a href="#group-by---having">GROUP BY - HAVING</a></li>
<li><a href="#order-by">ORDER BY</a></li>
<li><a href="#limit-%D0%B8-offset">LIMIT и OFFSET</a></li>
<li><a href="#update---update">Update - UPDATE</a></li>
<li><a href="#delete---delete">Delete - DELETE</a></li>
</ul>
</li>
<li><a href="#%D0%94%D0%BE%D0%BC%D0%B0%D1%88%D0%BD%D1%94-%D0%B7%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F">Домашнє завдання:</a></li>
<li><a href="#%D0%9B%D1%96%D1%82%D0%B5%D1%80%D0%B0%D1%82%D1%83%D1%80%D0%B0">Література:</a></li>
</ul>
<h2 id="Теорія-БД"><a class="header" href="#Теорія-БД">Теорія БД</a></h2>
<p>Ефективно опрацьовувати великий обсяг інформації можна лише за умови її зберігання у структурованому вигляді та наявності добре налагодженого доступу до неї. Для зберігання, накопичення, опрацювання та швидкого пошуку інформації існують електронні бази даних — файли (сукупності файлів) спеціального формату, які містять структуровані дані.</p>
<h3 id="База-даних"><a class="header" href="#База-даних"><strong>База даних</strong></a></h3>
<p>БД (англ. <em>atabase</em>, DB) - це структурований набір даних, що зберігається відповідно до визначених правил у пам’яті комп’ютерних систем.</p>
<p>В загальному випадку базою даних можна вважати будь-який впорядкований набір даних. Наприклад, паперову картотеку з формулярами про працівників підприємства у відділі кадрів. Але ми зосередимось на використанні баз даних в інформаційних системах.</p>
<p>Прикладами баз даних є Державний реєстр фізичних осіб України, онлайн-база ДАІ України, бібліотечні каталоги, банківські документи (облік клієнтів та їхніх рахунків) тощо.</p>
<p>База даних є сховищем упорядкованої сукупності даних. Для роботи з БД використовують системи керування базами даних.</p>
<p><strong>Систе́ма керування (управління) ба́зами да́них</strong> (СУБД, СКБД англ. <em>Database Management System</em>, DBMS) - це програмний комплекс, що забезпечує введення, зберігання, пошук, опрацювання даних у базі даних.</p>
<p>СКБД дозволяють ефективно працювати з базами даних, обсяг яких робить неможливим їх ручне опрацювання.</p>
<p>Через тісний зв’язок баз даних з СУБД під терміном «база даних» інколи необґрунтовано та неточно мають на увазі систему керування базами даних. Але варто розрізняти базу даних — сховище даних, та СУБД — засоби для роботи з базою даних. СУБД з інформаційної системи може бути видалена, але база даних продовжить існувати. І навпаки: СУБД може функціонувати без жодної бази даних.</p>
<p>Сучасні СКБД забезпечують функції щодо керування даними, які можна поділити на такі групи:</p>
<ul>
<li>Оголошення даних — створення, зміна та видалення визначень, які описують організацію даних.</li>
<li>Модифікація даних — додавання даних, їх редагування та видалення.</li>
<li>Отримання даних — надання даних за запитом застосунку у формі, яка дозволяє їх безпосереднє використання. Дані можуть надаватись або у формі, в якій вони зберігаються у базі даних, або в іншій формі (наприклад, через поєднання різних даних).</li>
<li>Адміністрування даних — реєстрування та відслідковування дій користувачів, дотримання безпеки роботи з даними, забезпечення надійності та цілісності даних, моніторинг продуктивності, резервне копіювання та відновлення даних тощо.</li>
</ul>
<p>До популярних СКБД належать:<br />
<em>Комерційні</em></p>
<ul>
<li>Microsoft SQL Server</li>
<li>Oracle DB2</li>
<li>Interbase</li>
<li>Informix</li>
<li>Sybase</li>
</ul>
<p><em>З відкритим кодом</em></p>
<ul>
<li>MySQL</li>
<li>PostgreSQL</li>
<li>Firebird</li>
<li>SQLite</li>
</ul>
<h3 id="Види-баз-даних"><a class="header" href="#Види-баз-даних">Види баз даних.</a></h3>
<p>Бази даних класифікують за різними критеріями.<br />
<img src="attachments/Pasted%20image%2020240403093916.png" alt="" /></p>
<p><strong>За моделлю організації даних</strong> розрізняють такі бази даних:</p>
<ul>
<li><em>Ієрархічна</em>. Модель, де використовується представлення бази даних у вигляді деревовидної (ієрархічної) структури, що складається з об’єктів (даних) різних рівнів. За ієрархічною моделлю функціонує файлова система комп’ютера.</li>
<li><em>Мережева</em> складається з набору екземплярів певного типу запису і набору екземплярів певного типу зв’язків між цими записами. Мережева модель даних об’єднує бази даних різних банків.
*Різниця між ієрархічною моделлю даних і мережевою полягає в тому, що в ієрархічних структурах запис-нащадок повинен мати тільки одного предка, а в мережевій структурі даних у нащадка може бути будь-яке число предків.</li>
<li><em>Реляційна</em> (від англ. relation — зв’язок) являє собою сукупність зв’язаних таблиць, що містять дані про об’єкти певного виду. Найвживаніші СКБД використовують реляційну модель даних.</li>
<li><em>Об’єктно-орієнтована</em> - це модель БД, в якій дані зберігаються як об’єкти, наділені певними властивостями та можливостями (методами) взаємодіяти з іншими об’єктами.</li>
<li><em>Об’єктно-реляційна</em>. Має спільні риси з двома попередніми моделями.</li>
<li><em>Функціональна</em>. Використовуються для вирішення аналітичних задач фінансового моделювання та управління продуктивністю. Підтримує інтерактивні обчислення: значення залежних клітинок автоматично оновлюються, коли змінюється значення клітинки.</li>
<li><em>Модель «сутність-зв’язок» або ER-модель</em> ( англ. Entityrelationship model або entity-relationship diagram) — модель даних, яка дозволяє описувати концептуальні схеми за допомогою узагальнених конструкцій блоків. ER-модель — це мета-модель даних, тобто засіб опису моделей даних. Існує ряд моделей для представлення знань, але одним з найзручніших інструментів уніфікованого представлення даних, незалежного від програмного забезпечення, що його реалізує, є модель «сутність-зв’язок». Важливим є той факт, що з моделі «сутністьзв’язок» можуть бути породжені всі існуючі моделі даних (ієрархічна, мережева, реляційна, об’єктна), тому вона є найзагальнішою.</li>
</ul>
<p><strong>За розміщенням даних</strong> :</p>
<ul>
<li><em>Локальна</em>, або централізована. Така база даних підтримується на одному комп’ютері.</li>
<li><em>Розподілена</em>. Частини такої бази даних розміщують на різних комп’ютерах мережі.</li>
</ul>
<p><strong>За технологією фізичного зберігання</strong> виділяють:</p>
<ul>
<li>БД у вторинній пам’яті (традиційні) – використовують жорсткий диск.</li>
<li>БД в оперативній пам’яті (in-memory database).</li>
<li>БД у третинній пам’яті (tertiary database) – середовищем постійного зберігання є від’єднаний від сервера пристрій масового зберігання.</li>
</ul>
<h3 id="Реляційна-модель"><a class="header" href="#Реляційна-модель">Реляційна модель</a></h3>
<p>Реляційна модель даних — логічна модель даних. Вперше була запропонована британським ученим співробітником компанії IBM <em>Едгаром Франком <a href="https://uk.wikipedia.org/wiki/%D0%95%D0%B4%D0%B3%D0%B0%D1%80_%D0%9A%D0%BE%D0%B4%D0%B4">Коддом</a></em> (E. F. Codd) в 1970 році в статті «A Relational Model of Data for Large Shared Data Banks». В даний час ця модель є фактичним стандартом, на який орієнтуються практично всі сучасні комерційні системи керування базами даних.</p>
<p>Реляційна модель орієнтована на організацію у вигляді двовимірних таблиць.<br />
Кожна реляційна таблиця являє собою двовимірний масив і має такі <em>властивості</em>:</p>
<ul>
<li>кожний елемент таблиці — один елемент даних</li>
<li>всі комірки в стовпці таблиці однорідні, тобто всі елементи в стовпці мають однаковий тип</li>
<li>кожний стовпець має унікальне ім’я</li>
<li>однакові рядки в таблиці відсутні</li>
<li>порядок наступності рядків і стовпців може бути довільним</li>
</ul>
<p><em>Базовими поняттями реляційних моделей є</em></p>
<ul>
<li>відношення</li>
<li>атрибут</li>
<li>кортеж</li>
</ul>
<p><img src="attachments/Pasted%20image%2020240403094127.png" alt="" /></p>
<p><em>Відношення</em> зручно представляти у формі таблиць, де кожен рядок є <em>кортеж</em>, а кожен стовпець — <em>атрибут</em>, визначений на деякому домені. Даний неформальний підхід до поняття відношення дає більш звичну для розробників і користувачів форму представлення, де реляційна база даних подається як кінцевий набір таблиць.</p>
<div class="table-wrapper"><table><thead><tr><th>Термін SQL</th><th>Термін реляційної БД</th><th>Опис</th></tr></thead><tbody>
<tr><td>Рядок</td><td>Кортеж або Запис</td><td>Набір даних, що представляє один елемент<br></td></tr>
<tr><td>Колонка</td><td>Атрибут або Поле</td><td>Позначений елемент кортежу, наприклад «Адреса» або «Дата народження»<br></td></tr>
<tr><td>Таблиця</td><td>Відношення або базове відношення</td><td>Набір кортежів, що мають однакові атрибути; набір стовпців і рядків<br></td></tr>
<tr><td>Відображення або Набір результатів</td><td>Похідне відношення</td><td>Будь-який набір кортежів; звіт про дані з RDBMS у відповідь на запит<br></td></tr>
</tbody></table>
</div>
<p>Будь-який кортеж будь-якого відношення відмінний від будь-якого іншого кортежу цього відношення, тобто іншими словами, будь-яке відношення має володіти первинним ключем. Вимога цілісності щодо посилань, або вимога зовнішнього ключа полягає в тому, що для кожного значення зовнішнього ключа, що з’являється у відношенні, на яке веде посилання, повинен знайтися кортеж з таким же значенням первинного ключа, або значення зовнішнього ключа повинно бути невизначеним (тобто ні на що не вказувати).</p>
<p>Атрибут, значення якого однозначно ідентифікує кортежі, називається ключовим (або просто ключем). Якщо кортежі ідентифікуються тільки зчепленням значень декількох атрибутів, то говорять, що відношення має складений ключ. Відношення може містити кілька ключів. Завжди один із ключів оголошується первинним, його значення не можуть оновлюватися.</p>
<p><strong>Переваги реляційної моделі</strong>:</p>
<ul>
<li>простота і доступність для розуміння користувачем. Єдиною використовуваною інформаційною конструкцією є «таблиця»;</li>
<li>суворі правила проектування, які базуються на математичному апараті;</li>
<li>повна незалежність даних. Зміни в прикладній програмі при зміні реляційної БД мінімальні;</li>
<li>для організації запитів і написання прикладного ПЗ немає необхідності знати конкретну організацію БД у зовнішній пам’яті.</li>
</ul>
<p><strong>Недоліки реляційної моделі:</strong></p>
<ul>
<li>далеко не завжди предметна область може бути представлена у вигляді «таблиць»;</li>
<li>в результаті логічного проектування з’являється множина «таблиць». Це призводить до труднощів розуміння структури даних;</li>
<li>БД займає відносно багато зовнішньої пам’яті;</li>
<li>відносно низька швидкість доступу до даних.</li>
</ul>
<p><em><strong>Реляційна база даних</strong></em> — база даних, заснована на реляційній моделі даних.<br />
Слово «реляційний» походить від англ. relation.<br />
Для роботи з реляційними БД застосовують реляційні СКБД. (РСКБД, RDBMS - relational database management system)</p>
<p><img src="attachments/Pasted%20image%2020240403094340.png" alt="" /></p>
<p><strong>Ключі.</strong><br />
<em>Ключ</em> — це стовпець (може бути декілька стовпців), що додається до таблиці і дозволяє встановити зв’язок із записами в іншій таблиці.</p>
<p>Існують ключі двох типів:</p>
<ul>
<li>первинні (PRIMARY KEY, PK)</li>
<li>вторинні (зовнішні). (FOREIGN KEY, FK)</li>
</ul>
<p><em>Первинний ключ</em> — це одне або кілька полів (стовпців), комбінація значень яких однозначно визначає кожний запис у таблиці. Первинний ключ не допускає значень Null і завжди повинен мати унікальний індекс. Первинний ключ використовується для зв’язування таблиці з зовнішніми ключами<br />
в інших таблицях.<br />
<em>Зовнішній (вторинний) ключ</em> — це одне або кілька полів (стовпців) у таблиці, що містять посилання на поле або поля первинного ключа в іншій таблиці. Зовнішній ключ визначає спосіб об’єднання таблиць.</p>
<p>З двох логічно пов’язаних таблиць одну називають таблицею первинного ключа або головною таблицею, а іншу таблицею вторинного (зовнішнього) ключа або підпорядкованою таблицею. СУБД дозволяють зіставити споріднені записи з обох таблиць і спільно вивести їх у формі, звіті або запиті.</p>
<p><em>Існує три типи первинних ключів:</em></p>
<ol>
<li>ключові поля лічильника (лічильник)</li>
<li>простий ключ</li>
<li>складовий ключ.</li>
</ol>
<p><em>Поле лічильника</em> (Тип даних «Лічильник»).<br />
Для кожного запису цього поля таблиці автоматично заноситься унікальне числове значення.</p>
<p><em>Простий ключ.</em><br />
Якщо поле містить унікальні значення, такі як коди чи інвентарні номери, то це поле можна визначити як первинний ключ. В якості ключа можна визначити всі поля, що містить дані, якщо це поле не містить повторювані значення або<br />
значення Null.</p>
<p><em>Складені ключі.</em><br />
У випадках, коли неможливо гарантувати унікальність значень кожного поля, існує можливість створити ключ, що складається з декількох полів. Найчастіше така ситуація виникає для таблиці, використовуваної для зв’язування двох таблиць відношенням «багато — до — багатьох».<br />
<img src="attachments/Pasted%20image%2020240403094409.png" alt="" /></p>
<h3 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h3>
<p><a href="https://www.postgresql.org/">PostgreSQL</a></p>
<p><img src="attachments/Pasted%20image%2020240403094443.png" alt="" /></p>
<p><em><strong>PostgreSQL</strong></em> (вимовляється «Пост-грес-К’ю-ель», або «постгрес») — об’єктно-реляційна система керування базами даних (СКБД).<br />
Сервер PostgreSQL написаний на мові C.</p>
<p><em><strong>Історія</strong></em><br />
PostgreSQL — широко розповсюджена система керування базами даних з відкритим початковим кодом. Прототип був розроблений в Каліфорнійському університеті Берклі в 1987 році під назвою POSTGRES, після чого активно розвивався і доповнювався. В червні 1990 року з’явилась друга версія із переробленою системою правил маніпулювання та роботи з таблицями, у 1991 році — третя версія, із доданою підтримкою одночасної роботи кількох менеджерів збереження, покращеним механізмом запитів і доповненою системою внутрішніх правил. В цей час POSTGRES використовувався для реалізації великих систем, таких як: система аналізу фінансових даних, пакет моніторингу функціональності потоків, база даних відстеження астероїдів, система медичної інформації, кілька географічних систем. POSTGRES також використовувався як навчальний інструмент в кількох університетах. 1992 року POSTGRES став головною СКБД наукового комп’ютерного проєкту Sequoia 2000. 1993 року кількість користувачів подвоїлась. Стало зрозуміло, що для підтримки й подальшого розвитку необхідні великі витрати часу на дослідження баз даних, тому офіційно проєкт Берклі було зупинено на версії 4.2. 1994 року Andrew Yu і Jolly Chen додали інтерпретатор мови SQL, вдосконалили початковий код і виклали в Інтернеті свою реалізацію під назвою Postgres95. 1996 року програмний продукт було перейменовано на PostgreSQL із початковою версією 6.0. Подальшою підтримкою й розробкою займається група спеціалістів у галузі баз даних, які добровільно приєднались до цього проєкту.</p>
<p>Як встановити - <a href="https://github.com/Bandydan/UPostgres/blob/master/psql0.md">Тут</a></p>
<p><a href="https://www.commandprompt.com/education/connecting-postgresql-using-psql-and-pgadmin/">Як підключити PgAdmin 4</a></p>
<h2 id="sql"><a class="header" href="#sql">SQL</a></h2>
<p><strong>SQL</strong> (/ˌɛsˌkjuːˈɛl/ або /ˈsiːkwəl/, англ. <em>Structured query language</em> — мова структурованих запитів) — декларативна мова програмування для взаємодії з базами даних, що застосовується для формування запитів, оновлення і керування реляційними БД, створення схеми бази даних та її модифікації, системи контролю за доступом до бази даних.<br />
Сама по собі SQL не є ані системою керування базами даних, ані окремим програмним продуктом. На відміну від дійсних мов програмування (C або Pascal), SQL може формувати інтерактивні запити або, бувши вбудованою в прикладні програми, виступати як інструкції для керування даними. Окрім цього, стандарт SQL містить функції для визначення зміни, перевірки та захисту даних.</p>
<p>SQL — це діалогова мова програмування для здійснення запиту і внесення змін до бази даних, а також керування базами даних. Багато баз даних підтримує SQL з розширеннями до стандартної мови. Ядро SQL формує командна мова, яка дозволяє здійснювати пошук, вставку, оновлення і вилучення даних за допомогою використання системи керування і адміністративних функцій.</p>
<h3 id="Синтаксис-sql"><a class="header" href="#Синтаксис-sql">Синтаксис SQL</a></h3>
<ul>
<li>
<p>Загальний формат інструкції SQL:</p>
<p>SELECT field_1<br />
FROM table_1<br />
WHERE criterion_1;</p>
</li>
<li>
<p>Ключові слова SQL НЕ чутливі до регістру: <code>select</code> те саме, що і <code>SELECT</code></p>
</li>
<li>
<p>Кожна інструкція закінчується крапкою з комою (;). Вона може стояти як у кінці останнього речення, так і окремо в рядку в кінці інструкції SQL.</p>
</li>
</ul>
<p><strong>Деякі з найважливіших команд SQL</strong></p>
<ul>
<li><code>SELECT</code> - витягує дані з бази даних</li>
<li><code>UPDATE</code> - оновлює дані в базі даних</li>
<li><code>DELETE</code> - видаляє дані з бази даних</li>
<li><code>INSERT INTO</code> - вставляє нові дані в базу даних</li>
<li><code>CREATE DATABASE</code> - створює нову базу даних</li>
<li><code>ALTER DATABASE</code> - змінює базу даних</li>
<li><code>CREATE TABLE</code> - створює нову таблицю</li>
<li><code>ALTER TABLE</code> - змінює таблицю</li>
<li><code>DROP TABLE</code> - видаляє таблицю</li>
<li><code>CREATE INDEX</code> - створює індекс (ключ пошуку)</li>
<li><code>DROP INDEX</code> - видаляє індекс</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Оператор</th><th>Опис</th><th>Приклад</th></tr></thead><tbody>
<tr><td><code>=</code></td><td>дорівнює</td><td><code>Author = 'Alcott'</code></td></tr>
<tr><td><code>&lt;&gt;</code></td><td>не дорівнює (багато СКБД приймають крім <code>&lt;&gt;</code> також <code>!=</code>)</td><td><code>Dept &lt;&gt; 'Sales'</code></td></tr>
<tr><td><code>&gt;</code></td><td>більше ніж</td><td><code>Hire_Date &gt; '2012-01-31'</code></td></tr>
<tr><td><code>&lt;</code></td><td>менше ніж</td><td><code>Bonus &lt; 50000.00</code></td></tr>
<tr><td><code>&gt;=</code></td><td>більше або дорівнює</td><td><code>Dependents &gt;= 2</code></td></tr>
<tr><td><code>&lt;=</code></td><td>менше або дорівнює</td><td><code>Rate &lt;= 0.05</code></td></tr>
<tr><td><code>BETWEEN</code></td><td>між двома величинами включно</td><td><code>Cost BETWEEN 100.00 AND 500.00</code></td></tr>
<tr><td>LIKE</td><td>співставлення тексту з шаблоном</td><td><code>First_Name LIKE 'Will%'</code></td></tr>
<tr><td><code>IN</code></td><td>одне з багатьох можливих значень</td><td><code>DeptCode IN (101, 103, 209)</code></td></tr>
<tr><td><code>IS</code> <em>or</em> <code>IS NOT</code></td><td>Порівняння з null (відсутністю даних)</td><td><code>Address IS NOT NULL</code></td></tr>
<tr><td><code>IS [NOT] TRUE</code> <em>or</em> <code>IS [NOT] FALSE</code></td><td>булева перевірка істинності</td><td><code>PaidVacation IS TRUE</code></td></tr>
<tr><td><code>IS NOT DISTINCT FROM</code></td><td>значення рівні або обоє null (обоє відсутні)</td><td><code>Debt IS NOT DISTINCT FROM - Receivables</code></td></tr>
<tr><td><code>AS</code></td><td>використовується для зміни назви колонки в результаті запиту</td><td><code>SELECT employee AS "department1"</code></td></tr>
</tbody></table>
</div>
<h2 id="Підключення-до-СУБД-postgresql"><a class="header" href="#Підключення-до-СУБД-postgresql">Підключення до СУБД PostgreSQL</a></h2>
<p>Якщо в системі встановлено СУБД PostgreSQL, можна запустити відповідну консольну програму PostgreSQL, яка дозволяє виконувати всі доступні операції з базами даних.</p>
<p>PostgreSQL не вміє працювати без бази даних. Ще до підключення до СУБД PostgreSQL необхідно створити їй базу даних або вибрати одну з існуючих. Для перегляду існуючих баз даних є зовнішня команда консолі:</p>
<pre><code class="language-sh">➜ psql -l
                         List of databases
   Name    | Owner    | Encoding | Collate | Ctype | Access privileges
-----------+-------+----------+---------+-------+-------------------
 postgres  | postgres | UTF8     | C       | C     |
 template0 | postgres | UTF8     | C       | C     | =c/postgres       +
 template1 | postgres | UTF8     | C       | C     | =c/postgres       +
 test      | postgres | UTF8     | C       | C     |
(4 rows)
</code></pre>
<p>Консольна команда для створення бази даних у PostgreSQL.</p>
<pre><code>createdb test
</code></pre>
<p>Після цього підключаємося до неї:</p>
<pre><code class="language-bash">psql test
</code></pre>
<p>Загальний вигляд команди підключення:</p>
<pre><code class="language-bash">psql -U {{ user }} -d {{ dbname }} -h {{ host }}
</code></pre>
<p>Про всяк випадок вкажу команду створення спеціального користувача для роботи з PostgreSQL з усіма можливостями:</p>
<pre><code class="language-sql"># Створення користувача з паролем
CREATE USER postgres WITH SUPERUSER PASSWORD 'password';
# Передача прав на основну настроювальну базу даних новому користувачу ALTER DATABASE postgres OWNER TO postgres;
# (НЕБЕЗПЕЧНО) Видалення користувача, під яким зайшли (НЕБЕЗПЕЧНО)
DROP USER USER_NAME;
</code></pre>
<h3 id="Створення-баз-даних-та-таблиць"><a class="header" href="#Створення-баз-даних-та-таблиць">Створення баз даних та таблиць</a></h3>
<p>Створення своєї бази даних зсередини консолі psql - справа нескладна:</p>
<pre><code class="language-sql">CREATE DATABASE test;
</code></pre>
<p>База створена. Підключемося до неї:</p>
<pre><code class="language-sql">\c test
You are now connected to database "test" as user "postgres".
</code></pre>
<pre><code class="language-sql">CREATE TABLE cars(id SERIAL PRIMARY KEY, brand TEXT NOT NULL);
</code></pre>
<p><a href="https://www.tutorialspoint.com/postgresql/postgresql_data_types.htm">Типи даних у PostgreSQL</a></p>
<p>Окремо про <a href="https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-serial/">SERIAL</a><br />
Важливо зазначити, що <code>SERIAL</code> не створює неявно індекс для стовпця та не робить стовпець стовпцем первинного ключа. Однак це можна легко зробити, вказавши обмеження <code>PRIMARY KEY</code> для стовпця <code>SERIAL</code>.</p>
<p>Для того, щоб подивитися список таблиць, використовуйте команду <code>\dt</code> або <code>\dt+</code></p>
<pre><code class="language-sh">postgresdb-# \dt
        List of relations
Schema | Name | Type  |    Owner
--------+------+-------+--------------
public | cars | table | postgres
(1 row)
</code></pre>
<p>Подивимося на результуючу таблицю:</p>
<pre><code class="language-sh">\d cars
                            Table "public.cars"
 Column |  Type   | Collation | Nullable |             Default
--------+---------+-----------+----------+----------------------------------
 id     | integer |           | not null | nextval('cars_id_seq'::regclass)
 brand  | text    |           | not null |
</code></pre>
<p>Команда <code>\d</code> (скорочення від <code>describe</code>) з ім’ям таблиці виводить короткий опис таблиці.</p>
<h3 id="Редагування-таблиці"><a class="header" href="#Редагування-таблиці">Редагування таблиці</a></h3>
<p>Для зміни існуючої таблиці є команда <code>alter table</code>:</p>
<p><strong>Додати стовпець</strong></p>
<pre><code class="language-sh">ALTER TABLE cars add column model varchar(100) not null;
ALTER TABLE

\d cars
                                    Table "public.cars"
 Column |          Type          | Collation | Nullable |             Default
--------+------------------------+-----------+----------+----------------------------------
 id     | integer                |           | not null | nextval('cars_id_seq'::regclass)
 brand  | text                   |           | not null |
 model  | character varying(100) |           | not null |
</code></pre>
<p>Ми додали до таблиці машин колонку із моделлю машини, використавши команду <code>alter table</code>. Тим самим шляхом видалимо цю колонку:</p>
<p><strong>Видалити стовпець</strong></p>
<pre><code class="language-sh">alter table cars drop column model;
ALTER TABLE
\d cars
                            Table "public.cars"
 Column |  Type   | Collation | Nullable |             Default
--------+---------+-----------+----------+----------------------------------
 id     | integer |           | not null | nextval('cars_id_seq'::regclass)
 brand  | text    |           | not null |
</code></pre>
<p><strong>Перейменувати стовпець</strong></p>
<p>Щоб перейменувати стовпець у таблиці, використовуйте наведений нижче синтаксис:</p>
<pre><code class="language-sh">ALTER  TABLE  table_name 
RENAME  COLUMN  old_name  to  new_name;
</code></pre>
<p>Команда <a href="http://www.postgresqltutorial.com/postgresql-alter-table/">alter table</a> досить складна, але багато що дозволяє. Команда, як і при створенні таблиці, дозволяє додавати і видаляти колонки, змінювати їх різними способами, додавати на них різні індекси, вішати ключі на таблиці і видаляти їх і так далі.</p>
<h3 id="Видалення-таблиці"><a class="header" href="#Видалення-таблиці">Видалення таблиці</a></h3>
<p>Для видалення таблиць є дві цікаві команди:<br />
<code>drop table</code> з ім’ям таблиці просто видаляє таблицю.</p>
<pre><code class="language-sh">DROP TABLE cars;

</code></pre>
<p><code>truncate table</code> з ім’ям таблиці видаляє лише вміст таблиці, не змінюючи її структури. Serial, якщо він є, зберігатиме своє значення, але є можливість скинути його в нуль, додавши параметр <code>RESTART IDENTITY</code>:</p>
<pre><code class="language-sh">TRUNCATE fattable RESTART IDENTITY;
</code></pre>
<p>База даних видаляється командою <code>drop database</code> з ім’ям таблиці та крапкою коми в кінці.</p>
<h2 id="crud-даних"><a class="header" href="#crud-даних">CRUD даних</a></h2>
<p><img src="attachments/Pasted%20image%2020240403101617.png" alt="" /></p>
<p>Коли база даних створена та таблиці в ній створені, коли все це зроблено правильним користувачем з правильними правами та рівнем доступу, саме час заповнити таблиці даними.<br />
У роботі з даними є лише 4 дії: створення, отримання, зміна та видалення даних. Для позначення цих процесів використовується абревіатура</p>
<p><strong>CRUD: Create, Read, Update, Delete</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>CRUD</th><th>SQL</th></tr></thead><tbody>
<tr><td>Create</td><td>INSERT</td></tr>
<tr><td>Read</td><td>SELECT</td></tr>
<tr><td>Update</td><td>UPDATE</td></tr>
<tr><td>Delete</td><td>DELETE</td></tr>
</tbody></table>
</div>
<p>Для експериментів із даними нам знадобиться таблиця. Наприклад, таблиця слів зі словника та таблиця словників. Про всяк випадок - команди створення цих таблиць та їх опис:</p>
<pre><code class="language-sql">CREATE TABLE vocabulary  
(  
    id SERIAL PRIMARY KEY,  
    name VARCHAR(255),  
    info TEXT  
);  
  
CREATE TABLE word  
(  
    id SERIAL PRIMARY KEY,  
    word VARCHAR(255),  
    vocabulary_id INTEGER REFERENCES vocabulary(id)  
);

\d vocabulary
                                    Table "public.vocabulary"
 Column |          Type          | Collation | Nullable |                Default
--------+------------------------+-----------+----------+----------------------------------------
 id     | integer                |           | not null | nextval('vocabulary_id_seq'::regclass)
 name   | character varying(255) |           |          |
 info   | text                   |           |          |

\d word
                                       Table "public.word"
    Column     |          Type          | Collation | Nullable |             Default
---------------+------------------------+-----------+----------+----------------------------------
 id            | integer                |           | not null | nextval('word_id_seq'::regclass)
 word          | character varying(255) |           |          |
 vocabulary_id | integer                |           |          |

</code></pre>
<h3 id="create---додавання-даних-insert"><a class="header" href="#create---додавання-даних-insert">Create - додавання даних: INSERT</a></h3>
<p>Для додавання даних до таблиці використовується оператор <strong><code>INSERT INTO</code></strong>. Оператор <strong><code>INSERT INTO</code></strong> буває декількох видів, і ми розглянемо основні:</p>
<h3 id="simple-insert"><a class="header" href="#simple-insert">Simple insert</a></h3>
<p>Найпростіший варіант вставки даних у таблицю виглядає так:</p>
<pre><code class="language-sh">insert into vocabulary (name) values ('verbs');
INSERT 0 1
</code></pre>
<p>Перевіримо наші дані найпростішим <strong><code>select</code></strong>:</p>
<pre><code class="language-sql">select * from vocabulary;
 id |          name           | info
----+-------------------------+------
  1 | verbs                   |
(1 row)
</code></pre>
<p>У цьому прикладі ми вставляємо запис в таблицю vocabulary, вказуючи конкретне значення для кожного стовпця.</p>
<h3 id="multiple-insert"><a class="header" href="#multiple-insert">Multiple insert</a></h3>
<pre><code class="language-sql">insert into vocabulary (name) values ('IT'), ('Silicon Valley season 1');
INSERT 0 2
</code></pre>
<p>Перевіримо:</p>
<pre><code class="language-sql">select * from vocabulary;

 id |          name           | info
----+-------------------------+------
  1 | verbs                   |
  2 | IT                      |
  3 | Silicon Valley season 1 |
(3 rows)
</code></pre>
<p>Код вставляє дані в наступних дужках у відповідні стовпці, зазначені в перших дужках. Таким чином, спочатку необхідно перерахувати стовпці (поля), в які планується вносити дані, а потім через кому перерахувати обгорнуті дужками набори даних для цих полів. Такий запит дозволяє додавати кілька записів разом.</p>
<h3 id="insert-from-select"><a class="header" href="#insert-from-select">Insert from select</a></h3>
<p>Можлива також вставка даних із результату запиту:</p>
<pre><code class="language-sql">insert into vocabulary select * from vocabulary;
INSERT 0 3

select * from vocabulary;

 id |          name           | info
----+-------------------------+------
  1 | verbs                   |
  2 | IT                      |
  3 | Silicon Valley season 1 |
  1 | verbs                   |
  2 | IT                      |
  3 | Silicon Valley season 1 |
(6 rows)
</code></pre>
<p>Тут наведено досить простий приклад, але, по суті, якщо ви збудуєте запит даних <code>SELECT</code>таким чином, щоб кількість стовпців в результаті відповідала необхідному, вказаному в зовнішньому запиті <code>INSERT</code>**, ви можете вбудувати запит досить серйозного рівня складності.</p>
<h3 id="read---вибірка-даних-select"><a class="header" href="#read---вибірка-даних-select">Read - вибірка даних: SELECT</a></h3>
<p>Запит <strong><code>SELECT</code></strong> використовується для отримання даних, і жодним чином їх не змінює. Структура його досить складна, і спробуємо розібрати її поступово і поетапно.</p>
<p>Мінімальний можливий запит має такий вигляд:</p>
<pre><code class="language-sql">select 1;
 ?column? 
----------
        1
(1 row)

</code></pre>
<p>Єдиним обов’язковим ключовим словом у запиті <strong><code>select</code></strong> є слово <code>SELECT</code> - вибрати.</p>
<p>Після цього слова слід писати:</p>
<ul>
<li>функції та оператори PostgreSQL (<a href="https://www.tutorialspoint.com/postgresql/postgresql_date_time.htm">наприклад, функції роботи з датою та часом</a>)</li>
</ul>
<pre><code class="language-sql">select CURRENT_TIME;

    current_time
--------------------
 16:54:45.183026+03
(1 row)
</code></pre>
<ul>
<li>рядки та числа</li>
<li>поля таблиць, тимчасових таблиць та уявлень, які ми збираємося вибирати</li>
<li>похідні від цих полів</li>
<li>Вирази</li>
</ul>
<p>Найчастіше <strong><code>SELECT</code></strong> використовується для роботи з даними з таблиць, і для цього потрібно вказати ці таблиці. Таблиці, якими здійснюється вибірка, перераховуються після ключового слова <strong><code>FROM</code></strong>:</p>
<pre><code class="language-sql">SELECT * FROM books;
</code></pre>
<p>Наведений вище запит вибирає всі поля (за це відповідає зірочка) із таблиці books.
Максимально докладна схема запиту <code>select</code> виглядає так:</p>
<pre><code class="language-sql">SELECT
    &lt;field1&gt;,
    &lt;field2&gt;,
    &lt;field3&gt;
    ...
FROM
    &lt;table1&gt;,
    &lt;table2&gt;,
    &lt;joins&gt;,
    &lt;views&gt;,
    &lt;temp_table&gt;
    ...
WHERE
    &lt;cond&gt;
    
ORDER BY
    &lt;field1&gt; ASC
    &lt;field3&gt; DESC
GROUP BY
    &lt;field 1&gt;
HAVING
    &lt;cond with aggr function&gt;
LIMIT
    N,M
</code></pre>
<p>Нижче наведений текстовий опис основних елементів структури запиту <strong><code>SELECT</code></strong>, докладніший опис з прикладами буде наведено пізніше.</p>
<ol>
<li>Після ключового слова <strong><code>SELECT</code></strong> йде перелік полів таблиць, функцій, що обчислюються з цих полів, констант, незалежних від записів функцій. Для вказівки всіх полів використовується зірочка. Цей пункт є єдиним обов’язковим пунктом у запиті <strong><code>SELECT</code></strong>, інші опціональні.</li>
<li>Далі, після ключового слова <strong><code>FROM</code></strong> слідує перелік таблиць, уявлень та тимчасових таблиць, звідки ведеться вибірка. Таблиці можуть бути перераховані, а можуть бути приєднані до інших таблиць за описаними окремо правил, тобто. за допомогою <strong><code>JOIN</code></strong>.</li>
<li>Далі слідує умова <strong><code>WHERE</code></strong>, що пропускає лише ті записи, які задовольняють перерахованим у <strong><code>WHERE</code></strong> умовам. Всі записи, що не пройшли перевірку, відфільтровуються і не демонструються.</li>
<li>Після фільтру <strong><code>WHERE</code></strong> може слідувати групування записів.</li>
<li>Угруповання виконується за допомогою ключових слів <strong><code>GROUP BY</code></strong>. Суть угруповання в тому, що записи можуть об’єднуватися за ознакою або декількома ознаками в один запис, який несе у собі якусь загальну для всіх записів групи інформацію або результат обробки інформації по всій групі. Конструкція <strong><code>GROUP BY</code></strong> може включати ключове слово <strong><code>HAVING</code></strong>, що дозволяє фільтрувати результати груповання.</li>
<li>Важливо відзначити, що груповання дозволяє використовувати аггрегатні функції як в <strong><code>HAVING</code></strong>, так і після <strong><code>SELECT</code></strong>.</li>
<li>Після групування може відбутися сортування записів за допомогою ключових слів <strong>ORDER BY</strong>. При групуванні вказується поле або перелік полів, за яким необхідно відсортувати, також можна вказати напрямок сортування. За умовчанням здійснюється сортування за зростанням <code>ASC</code>. Сортування за спаданням здійснюється за допомогою ключового слова <strong><code>DESC</code></strong>.</li>
<li>Наприкінці запиту можливе додавання обмежень на кількість записів. Слово <strong><code>LIMIT</code></strong> та цифрою після вказує, скільки записів ви хочете бачити в результаті. Якщо після слова <strong><code>LIMIT</code></strong> написати <code>OFFSET</code> і цифру. -можна пропустити частину записів <strong><code>LIMIT 20 OFFSET 5</code></strong> пропустить 5 записів та покаже вам 20 наступних.</li>
<li>PostgreSQL надає альтернативу LIMIT - <strong><code>FETCH</code></strong>. На думку розробників, <strong><code>FETCH</code></strong> краще відповідає стандартам SQL мови.</li>
</ol>
<h3 id="Практика-з-select-та-insert"><a class="header" href="#Практика-з-select-та-insert">Практика з SELECT та INSERT</a></h3>
<h3 id="distinct"><a class="header" href="#distinct">DISTINCT</a></h3>
<pre><code class="language-sql">select * from vocabulary;
 id |          name           | info
----+-------------------------+------
  1 | verbs                   |
  2 | IT                      |
  3 | Silicon Valley season 1 |
  1 | verbs                   |
  2 | IT                      |
  3 | Silicon Valley season 1 |
(6 rows)

select distinct * from vocabulary;
 id |          name           | info
----+-------------------------+------
  2 | IT                      |
  1 | verbs                   |
  3 | Silicon Valley season 1 |
(3 rows)
</code></pre>
<p>Умова <strong><code>DISTINCT</code></strong> відкидає дублікати в результаті запиту, залишаючи лише унікальні записи.</p>
<h3 id="where"><a class="header" href="#where">WHERE</a></h3>
<p>Додамо кілька слів до нашої таблиці слів:</p>
<pre><code class="language-sql">insert into word (word, vocabulary_id) values('have', 1), ('IP', 2), ('Kanban', 3);
INSERT 0 3

insert into word (word, vocabulary_id) values('have', 7), ('TCP/IP', 2), ('Function', 3);
INSERT 0 3
</code></pre>
<p>Тепер виберемо всі слова та кілька разів відфільтруємо їх за допомогою <strong><code>where</code></strong>:</p>
<pre><code class="language-sql">select * from word;
 id |   word   | vocabulary_id
----+----------+---------------
  1 | have     |             1
  2 | IP       |             2
  3 | Kanban   |             3
  4 | have     |             7
  5 | TCP/IP   |             2
  6 | Function |             3
(6 rows)

select word from word where id &gt; 5;
   word
----------
 Function
(1 row)

select word from word where id &gt; 3;
   word
----------
 have
 TCP/IP
 Function
(3 rows)
</code></pre>
<p>Трохи більше фільтрації та перерахування полів:</p>
<pre><code class="language-sql">select word from word where vocabulary_id &lt; 4 and id &lt; 6;
  word
--------
 have
 IP
 Kanban
 TCP/IP
(4 rows)

select id, word, vocabulary_id from word where vocabulary_id &lt; 4 and id &lt; 6;
 id |  word  | vocabulary_id
----+--------+---------------
  1 | have   |             1
  2 | IP     |             2
  3 | Kanban |             3
  5 | TCP/IP |             2
(4 rows)
</code></pre>
<p>Умови можна комбінувати за допомогою <code>AND</code> та <code>OR</code>.</p>
<h3 id="group-by"><a class="header" href="#group-by">GROUP BY</a></h3>
<p>Групувати можна дані, які повторюються у групах і не суперечитимуть умовам угруповання. При групуванні можна логічно використовувати агрегатні функції. Агрегатні функції - особливі функції SQL, які застосовуються до всіх записів в результатів вибірки, або до груп.<br />
<code>COUNT</code> – одна з таких функцій.<br />
Більше агрегатних функції <a href="https://krypton.com.ua/rozdil-4-zapyty/agregatni-funkcziyi/">тут</a> (SUM, MIN, MAX)</p>
<pre><code class="language-sql">select vocabulary_id from word where vocabulary_id &lt; 4 
and id &lt; 6 group by vocabulary_id;
 vocabulary_id
---------------
             3
             1
             2
(3 rows)

select count(*), vocabulary_id from word where vocabulary_id &lt; 4
and id &lt; 6 group by vocabulary_id;
 count | vocabulary_id
-------+---------------
     1 |             3
     1 |             1
     2 |             2
(3 rows)
</code></pre>
<h3 id="group-by---having"><a class="header" href="#group-by---having">GROUP BY - HAVING</a></h3>
<p>Ключове слово <code>HAVING</code> додається лише після <code>GROUP BY</code> для додаткової фільтрації результатів запиту. <code>WHERE</code> фільтрує їх до угруповання, <code>HAVING</code> фільтрує згруповані.</p>
<pre><code class="language-sql">select count(*), vocabulary_id from word where vocabulary_id &lt; 4
and id &lt; 6 group by vocabulary_id having count(*) &gt; 1;

 count | vocabulary_id
-------+---------------
     2 |             2
(1 row)
</code></pre>
<p>У цьому запиті відображаються лише ті групи слів, які зустрілися більше одного разу.</p>
<h3 id="order-by"><a class="header" href="#order-by">ORDER BY</a></h3>
<p>Окрім сортування за зростанням <code>ASC</code> або спаданням <code>DESC</code>, можна ще вказувати, за яким полем це робити. Поле можна прописати як за назвою, так і номером за порядком.</p>
<pre><code class="language-sql">select * from word order by vocabulary_id;
 id |   word   | vocabulary_id
----+----------+---------------
  1 | have     |             1
  2 | IP       |             2
  5 | TCP/IP   |             2
  3 | Kanban   |             3
  6 | Function |             3
  4 | have     |             7
(6 rows)

select * from word order by 3;
 id |   word   | vocabulary_id
----+----------+---------------
  1 | have     |             1
  2 | IP       |             2
  5 | TCP/IP   |             2
  3 | Kanban   |             3
  6 | Function |             3
  4 | have     |             7
(6 rows)

select * from word order by 3, 2;
 id |   word   | vocabulary_id
----+----------+---------------
  1 | have     |             1
  2 | IP       |             2
  5 | TCP/IP   |             2
  6 | Function |             3
  3 | Kanban   |             3
  4 | have     |             7
(6 rows)
</code></pre>
<h3 id="limit-и-offset"><a class="header" href="#limit-и-offset">LIMIT и OFFSET</a></h3>
<pre><code class="language-sql">select * from word order by 3, 2 limit 3;
 id |  word  | vocabulary_id
----+--------+---------------
  1 | have   |             1
  2 | IP     |             2
  5 | TCP/IP |             2
(3 rows)

select * from word order by 3, 2 limit 3 offset 3;
 id |   word   | vocabulary_id
----+----------+---------------
  6 | Function |             3
  3 | Kanban   |             3
  4 | have     |             7
(3 rows)
</code></pre>
<p><strong>Зверніть увагу!</strong><br />
<code>UPDATE</code> та <code>DELETE</code> виконувати з <code>WHERE</code> (умовою).<br />
Без цього оновляться чи видаляться усі записи!</p>
<h3 id="update---update"><a class="header" href="#update---update">Update - UPDATE</a></h3>
<p>Якщо треба оновити дані, використовуємо <code>UPDATE</code><br />
Загальний вигляд:</p>
<pre><code class="language-sql">UPDATE table_name SET column1 = value1, column2 = value2_, ... WHERE condition;
</code></pre>
<pre><code class="language-sql">UPDATE  word  
SET  word = 'Agile'  
WHERE  id = 3;
</code></pre>
<h3 id="delete---delete"><a class="header" href="#delete---delete">Delete - DELETE</a></h3>
<p>Для видалення використовуємо <code>DELETE</code><br />
Загальний вигляд:</p>
<pre><code class="language-sql">DELETE  FROM  table_name 
WHERE  condition;
</code></pre>
<pre><code class="language-sql">DELETE FROM word WHERE id = 6;
</code></pre>
<h2 id="Домашнє-завдання"><a class="header" href="#Домашнє-завдання">Домашнє завдання:</a></h2>
<p>Результати напрацювань заливаємо на Github так, щоб можна було легко знайти їх за номером уроку.<br />
Розширення файлу .sql<br />
У якому і будуть запити один за одним</p>
<ol start="0">
<li>Встановити PostgreSQL</li>
<li>Практикуємо все, що пройдено на уроці.</li>
<li>Cтворити базу даних фільмів із таблицями акторів, фільмів, режисерів.</li>
<li>Додати дані в таблицях.</li>
<li>Додатково ознайомитися з FETCH (аналог LIMIT) та TRUNCATE (аналог DROP TABLE + CREATE TABLE)</li>
</ol>
<h2 id="Література"><a class="header" href="#Література">Література:</a></h2>
<ol start="0">
<li>📖 <a href="https://krypton.com.ua/vvedenye-v-postgresql/">Введення в PostgreSQL</a></li>
<li>📖 <a href="https://w3schoolsua.github.io/sql/index.html#gsc.tab=0">SQL Підручник</a></li>
<li>📖 <a href="https://sqlzoo.net/wiki/SQL_Tutorial">SQL Tutorial</a></li>
<li>🎥 <a href="https://www.khanacademy.org/computing/computer-programming/sql/sql-basics/v/welcome-to-sql">SQL basics</a></li>
<li><a href="https://www.postgresql.org/docs/current/app-psql.html#APP-PSQL-META-COMMANDS">Метакоманди типу <code>\q</code>:</a></li>
<li><a href="https://krypton.com.ua/rozdil-4-zapyty/agregatni-funkcziyi/">Агрегатні функції</a></li>
<li><a href="http://www.postgresqltutorial.com/postgresql-fetch/">FETCH</a></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next prefetch" href="db/12-postgresql-join.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next prefetch" href="db/12-postgresql-join.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
