<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ALevel</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="db/11-postgresql-crud.html"><strong aria-hidden="true">1.</strong> 11-postgresql-crud</a></li><li class="chapter-item expanded "><a href="db/12-postgresql-join.html"><strong aria-hidden="true">2.</strong> 12-postgresql-join</a></li><li class="chapter-item expanded "><a href="db/13-postgresql-acid-normalization.html"><strong aria-hidden="true">3.</strong> 13-postgresql-acid-normalization</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ALevel</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="db/11-postgresql-crud.excalidraw.html">11-postgresql-crud.excalidraw</a></p>
<h1 id="posgresql-crud-таблиць-crud-записів"><a class="header" href="#posgresql-crud-таблиць-crud-записів">PosgreSQL. CRUD таблиць, CRUD записів.</a></h1>
<p><img src="db/attachments/Pasted%20image%2020240403093533.png" alt="" /></p>
<h1 id="Зміст"><a class="header" href="#Зміст">Зміст</a></h1>
<ul>
<li><a href="db/11-postgresql-crud.html#%D0%A2%D0%B5%D0%BE%D1%80%D1%96%D1%8F-%D0%91%D0%94">Теорія БД</a>
<ul>
<li><a href="db/11-postgresql-crud.html#%D0%91%D0%B0%D0%B7%D0%B0-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85"><strong>База даних</strong></a></li>
<li><a href="db/11-postgresql-crud.html#%D0%92%D0%B8%D0%B4%D0%B8-%D0%B1%D0%B0%D0%B7-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85">Види баз даних.</a></li>
<li><a href="db/11-postgresql-crud.html#%D0%A0%D0%B5%D0%BB%D1%8F%D1%86%D1%96%D0%B9%D0%BD%D0%B0-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C">Реляційна модель</a></li>
<li><a href="db/11-postgresql-crud.html#postgresql">PostgreSQL</a></li>
</ul>
</li>
<li><a href="db/11-postgresql-crud.html#sql">SQL</a>
<ul>
<li><a href="db/11-postgresql-crud.html#%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81-sql">Синтаксис SQL</a></li>
</ul>
</li>
<li><a href="db/11-postgresql-crud.html#%D0%9F%D1%96%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%BD%D1%8F-%D0%B4%D0%BE-%D0%A1%D0%A3%D0%91%D0%94-postgresql">Підключення до СУБД PostgreSQL</a>
<ul>
<li><a href="db/11-postgresql-crud.html#%D0%A1%D1%82%D0%B2%D0%BE%D1%80%D0%B5%D0%BD%D0%BD%D1%8F-%D0%B1%D0%B0%D0%B7-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85-%D1%82%D0%B0-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8C">Створення баз даних та таблиць</a></li>
<li><a href="db/11-postgresql-crud.html#%D0%A0%D0%B5%D0%B4%D0%B0%D0%B3%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%96">Редагування таблиці</a></li>
<li><a href="db/11-postgresql-crud.html#%D0%92%D0%B8%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%96">Видалення таблиці</a></li>
</ul>
</li>
<li><a href="db/11-postgresql-crud.html#crud-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85">CRUD даних</a>
<ul>
<li><a href="db/11-postgresql-crud.html#create---%D0%B4%D0%BE%D0%B4%D0%B0%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85-insert">Create - додавання даних: INSERT</a></li>
<li><a href="db/11-postgresql-crud.html#simple-insert">Simple insert</a></li>
<li><a href="db/11-postgresql-crud.html#multiple-insert">Multiple insert</a></li>
<li><a href="db/11-postgresql-crud.html#insert-from-select">Insert from select</a></li>
<li><a href="db/11-postgresql-crud.html#read---%D0%B2%D0%B8%D0%B1%D1%96%D1%80%D0%BA%D0%B0-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85-select">Read - вибірка даних: SELECT</a></li>
<li><a href="db/11-postgresql-crud.html#%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0-%D0%B7-select-%D1%82%D0%B0-insert">Практика з SELECT та INSERT</a></li>
<li><a href="db/11-postgresql-crud.html#distinct">DISTINCT</a></li>
<li><a href="db/11-postgresql-crud.html#where">WHERE</a></li>
<li><a href="db/11-postgresql-crud.html#group-by">GROUP BY</a></li>
<li><a href="db/11-postgresql-crud.html#group-by---having">GROUP BY - HAVING</a></li>
<li><a href="db/11-postgresql-crud.html#order-by">ORDER BY</a></li>
<li><a href="db/11-postgresql-crud.html#limit-%D0%B8-offset">LIMIT и OFFSET</a></li>
<li><a href="db/11-postgresql-crud.html#update---update">Update - UPDATE</a></li>
<li><a href="db/11-postgresql-crud.html#delete---delete">Delete - DELETE</a></li>
</ul>
</li>
<li><a href="db/11-postgresql-crud.html#%D0%94%D0%BE%D0%BC%D0%B0%D1%88%D0%BD%D1%94-%D0%B7%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F">Домашнє завдання:</a></li>
<li><a href="db/11-postgresql-crud.html#%D0%9B%D1%96%D1%82%D0%B5%D1%80%D0%B0%D1%82%D1%83%D1%80%D0%B0">Література:</a></li>
</ul>
<h2 id="Теорія-БД"><a class="header" href="#Теорія-БД">Теорія БД</a></h2>
<p>Ефективно опрацьовувати великий обсяг інформації можна лише за умови її зберігання у структурованому вигляді та наявності добре налагодженого доступу до неї. Для зберігання, накопичення, опрацювання та швидкого пошуку інформації існують електронні бази даних — файли (сукупності файлів) спеціального формату, які містять структуровані дані.</p>
<h3 id="База-даних"><a class="header" href="#База-даних"><strong>База даних</strong></a></h3>
<p>БД (англ. <em>atabase</em>, DB) - це структурований набір даних, що зберігається відповідно до визначених правил у пам’яті комп’ютерних систем.</p>
<p>В загальному випадку базою даних можна вважати будь-який впорядкований набір даних. Наприклад, паперову картотеку з формулярами про працівників підприємства у відділі кадрів. Але ми зосередимось на використанні баз даних в інформаційних системах.</p>
<p>Прикладами баз даних є Державний реєстр фізичних осіб України, онлайн-база ДАІ України, бібліотечні каталоги, банківські документи (облік клієнтів та їхніх рахунків) тощо.</p>
<p>База даних є сховищем упорядкованої сукупності даних. Для роботи з БД використовують системи керування базами даних.</p>
<p><strong>Систе́ма керування (управління) ба́зами да́них</strong> (СУБД, СКБД англ. <em>Database Management System</em>, DBMS) - це програмний комплекс, що забезпечує введення, зберігання, пошук, опрацювання даних у базі даних.</p>
<p>СКБД дозволяють ефективно працювати з базами даних, обсяг яких робить неможливим їх ручне опрацювання.</p>
<p>Через тісний зв’язок баз даних з СУБД під терміном «база даних» інколи необґрунтовано та неточно мають на увазі систему керування базами даних. Але варто розрізняти базу даних — сховище даних, та СУБД — засоби для роботи з базою даних. СУБД з інформаційної системи може бути видалена, але база даних продовжить існувати. І навпаки: СУБД може функціонувати без жодної бази даних.</p>
<p>Сучасні СКБД забезпечують функції щодо керування даними, які можна поділити на такі групи:</p>
<ul>
<li>Оголошення даних — створення, зміна та видалення визначень, які описують організацію даних.</li>
<li>Модифікація даних — додавання даних, їх редагування та видалення.</li>
<li>Отримання даних — надання даних за запитом застосунку у формі, яка дозволяє їх безпосереднє використання. Дані можуть надаватись або у формі, в якій вони зберігаються у базі даних, або в іншій формі (наприклад, через поєднання різних даних).</li>
<li>Адміністрування даних — реєстрування та відслідковування дій користувачів, дотримання безпеки роботи з даними, забезпечення надійності та цілісності даних, моніторинг продуктивності, резервне копіювання та відновлення даних тощо.</li>
</ul>
<p>До популярних СКБД належать:<br />
<em>Комерційні</em></p>
<ul>
<li>Microsoft SQL Server</li>
<li>Oracle DB2</li>
<li>Interbase</li>
<li>Informix</li>
<li>Sybase</li>
</ul>
<p><em>З відкритим кодом</em></p>
<ul>
<li>MySQL</li>
<li>PostgreSQL</li>
<li>Firebird</li>
<li>SQLite</li>
</ul>
<h3 id="Види-баз-даних"><a class="header" href="#Види-баз-даних">Види баз даних.</a></h3>
<p>Бази даних класифікують за різними критеріями.<br />
<img src="db/attachments/Pasted%20image%2020240403093916.png" alt="" /></p>
<p><strong>За моделлю організації даних</strong> розрізняють такі бази даних:</p>
<ul>
<li><em>Ієрархічна</em>. Модель, де використовується представлення бази даних у вигляді деревовидної (ієрархічної) структури, що складається з об’єктів (даних) різних рівнів. За ієрархічною моделлю функціонує файлова система комп’ютера.</li>
<li><em>Мережева</em> складається з набору екземплярів певного типу запису і набору екземплярів певного типу зв’язків між цими записами. Мережева модель даних об’єднує бази даних різних банків.
*Різниця між ієрархічною моделлю даних і мережевою полягає в тому, що в ієрархічних структурах запис-нащадок повинен мати тільки одного предка, а в мережевій структурі даних у нащадка може бути будь-яке число предків.</li>
<li><em>Реляційна</em> (від англ. relation — зв’язок) являє собою сукупність зв’язаних таблиць, що містять дані про об’єкти певного виду. Найвживаніші СКБД використовують реляційну модель даних.</li>
<li><em>Об’єктно-орієнтована</em> - це модель БД, в якій дані зберігаються як об’єкти, наділені певними властивостями та можливостями (методами) взаємодіяти з іншими об’єктами.</li>
<li><em>Об’єктно-реляційна</em>. Має спільні риси з двома попередніми моделями.</li>
<li><em>Функціональна</em>. Використовуються для вирішення аналітичних задач фінансового моделювання та управління продуктивністю. Підтримує інтерактивні обчислення: значення залежних клітинок автоматично оновлюються, коли змінюється значення клітинки.</li>
<li><em>Модель «сутність-зв’язок» або ER-модель</em> ( англ. Entityrelationship model або entity-relationship diagram) — модель даних, яка дозволяє описувати концептуальні схеми за допомогою узагальнених конструкцій блоків. ER-модель — це мета-модель даних, тобто засіб опису моделей даних. Існує ряд моделей для представлення знань, але одним з найзручніших інструментів уніфікованого представлення даних, незалежного від програмного забезпечення, що його реалізує, є модель «сутність-зв’язок». Важливим є той факт, що з моделі «сутністьзв’язок» можуть бути породжені всі існуючі моделі даних (ієрархічна, мережева, реляційна, об’єктна), тому вона є найзагальнішою.</li>
</ul>
<p><strong>За розміщенням даних</strong> :</p>
<ul>
<li><em>Локальна</em>, або централізована. Така база даних підтримується на одному комп’ютері.</li>
<li><em>Розподілена</em>. Частини такої бази даних розміщують на різних комп’ютерах мережі.</li>
</ul>
<p><strong>За технологією фізичного зберігання</strong> виділяють:</p>
<ul>
<li>БД у вторинній пам’яті (традиційні) – використовують жорсткий диск.</li>
<li>БД в оперативній пам’яті (in-memory database).</li>
<li>БД у третинній пам’яті (tertiary database) – середовищем постійного зберігання є від’єднаний від сервера пристрій масового зберігання.</li>
</ul>
<h3 id="Реляційна-модель"><a class="header" href="#Реляційна-модель">Реляційна модель</a></h3>
<p>Реляційна модель даних — логічна модель даних. Вперше була запропонована британським ученим співробітником компанії IBM <em>Едгаром Франком <a href="https://uk.wikipedia.org/wiki/%D0%95%D0%B4%D0%B3%D0%B0%D1%80_%D0%9A%D0%BE%D0%B4%D0%B4">Коддом</a></em> (E. F. Codd) в 1970 році в статті «A Relational Model of Data for Large Shared Data Banks». В даний час ця модель є фактичним стандартом, на який орієнтуються практично всі сучасні комерційні системи керування базами даних.</p>
<p>Реляційна модель орієнтована на організацію у вигляді двовимірних таблиць.<br />
Кожна реляційна таблиця являє собою двовимірний масив і має такі <em>властивості</em>:</p>
<ul>
<li>кожний елемент таблиці — один елемент даних</li>
<li>всі комірки в стовпці таблиці однорідні, тобто всі елементи в стовпці мають однаковий тип</li>
<li>кожний стовпець має унікальне ім’я</li>
<li>однакові рядки в таблиці відсутні</li>
<li>порядок наступності рядків і стовпців може бути довільним</li>
</ul>
<p><em>Базовими поняттями реляційних моделей є</em></p>
<ul>
<li>відношення</li>
<li>атрибут</li>
<li>кортеж</li>
</ul>
<p><img src="db/attachments/Pasted%20image%2020240403094127.png" alt="" /></p>
<p><em>Відношення</em> зручно представляти у формі таблиць, де кожен рядок є <em>кортеж</em>, а кожен стовпець — <em>атрибут</em>, визначений на деякому домені. Даний неформальний підхід до поняття відношення дає більш звичну для розробників і користувачів форму представлення, де реляційна база даних подається як кінцевий набір таблиць.</p>
<div class="table-wrapper"><table><thead><tr><th>Термін SQL</th><th>Термін реляційної БД</th><th>Опис</th></tr></thead><tbody>
<tr><td>Рядок</td><td>Кортеж або Запис</td><td>Набір даних, що представляє один елемент<br></td></tr>
<tr><td>Колонка</td><td>Атрибут або Поле</td><td>Позначений елемент кортежу, наприклад «Адреса» або «Дата народження»<br></td></tr>
<tr><td>Таблиця</td><td>Відношення або базове відношення</td><td>Набір кортежів, що мають однакові атрибути; набір стовпців і рядків<br></td></tr>
<tr><td>Відображення або Набір результатів</td><td>Похідне відношення</td><td>Будь-який набір кортежів; звіт про дані з RDBMS у відповідь на запит<br></td></tr>
</tbody></table>
</div>
<p>Будь-який кортеж будь-якого відношення відмінний від будь-якого іншого кортежу цього відношення, тобто іншими словами, будь-яке відношення має володіти первинним ключем. Вимога цілісності щодо посилань, або вимога зовнішнього ключа полягає в тому, що для кожного значення зовнішнього ключа, що з’являється у відношенні, на яке веде посилання, повинен знайтися кортеж з таким же значенням первинного ключа, або значення зовнішнього ключа повинно бути невизначеним (тобто ні на що не вказувати).</p>
<p>Атрибут, значення якого однозначно ідентифікує кортежі, називається ключовим (або просто ключем). Якщо кортежі ідентифікуються тільки зчепленням значень декількох атрибутів, то говорять, що відношення має складений ключ. Відношення може містити кілька ключів. Завжди один із ключів оголошується первинним, його значення не можуть оновлюватися.</p>
<p><strong>Переваги реляційної моделі</strong>:</p>
<ul>
<li>простота і доступність для розуміння користувачем. Єдиною використовуваною інформаційною конструкцією є «таблиця»;</li>
<li>суворі правила проектування, які базуються на математичному апараті;</li>
<li>повна незалежність даних. Зміни в прикладній програмі при зміні реляційної БД мінімальні;</li>
<li>для організації запитів і написання прикладного ПЗ немає необхідності знати конкретну організацію БД у зовнішній пам’яті.</li>
</ul>
<p><strong>Недоліки реляційної моделі:</strong></p>
<ul>
<li>далеко не завжди предметна область може бути представлена у вигляді «таблиць»;</li>
<li>в результаті логічного проектування з’являється множина «таблиць». Це призводить до труднощів розуміння структури даних;</li>
<li>БД займає відносно багато зовнішньої пам’яті;</li>
<li>відносно низька швидкість доступу до даних.</li>
</ul>
<p><em><strong>Реляційна база даних</strong></em> — база даних, заснована на реляційній моделі даних.<br />
Слово «реляційний» походить від англ. relation.<br />
Для роботи з реляційними БД застосовують реляційні СКБД. (РСКБД, RDBMS - relational database management system)</p>
<p><img src="db/attachments/Pasted%20image%2020240403094340.png" alt="" /></p>
<p><strong>Ключі.</strong><br />
<em>Ключ</em> — це стовпець (може бути декілька стовпців), що додається до таблиці і дозволяє встановити зв’язок із записами в іншій таблиці.</p>
<p>Існують ключі двох типів:</p>
<ul>
<li>первинні (PRIMARY KEY, PK)</li>
<li>вторинні (зовнішні). (FOREIGN KEY, FK)</li>
</ul>
<p><em>Первинний ключ</em> — це одне або кілька полів (стовпців), комбінація значень яких однозначно визначає кожний запис у таблиці. Первинний ключ не допускає значень Null і завжди повинен мати унікальний індекс. Первинний ключ використовується для зв’язування таблиці з зовнішніми ключами<br />
в інших таблицях.<br />
<em>Зовнішній (вторинний) ключ</em> — це одне або кілька полів (стовпців) у таблиці, що містять посилання на поле або поля первинного ключа в іншій таблиці. Зовнішній ключ визначає спосіб об’єднання таблиць.</p>
<p>З двох логічно пов’язаних таблиць одну називають таблицею первинного ключа або головною таблицею, а іншу таблицею вторинного (зовнішнього) ключа або підпорядкованою таблицею. СУБД дозволяють зіставити споріднені записи з обох таблиць і спільно вивести їх у формі, звіті або запиті.</p>
<p><em>Існує три типи первинних ключів:</em></p>
<ol>
<li>ключові поля лічильника (лічильник)</li>
<li>простий ключ</li>
<li>складовий ключ.</li>
</ol>
<p><em>Поле лічильника</em> (Тип даних «Лічильник»).<br />
Для кожного запису цього поля таблиці автоматично заноситься унікальне числове значення.</p>
<p><em>Простий ключ.</em><br />
Якщо поле містить унікальні значення, такі як коди чи інвентарні номери, то це поле можна визначити як первинний ключ. В якості ключа можна визначити всі поля, що містить дані, якщо це поле не містить повторювані значення або<br />
значення Null.</p>
<p><em>Складені ключі.</em><br />
У випадках, коли неможливо гарантувати унікальність значень кожного поля, існує можливість створити ключ, що складається з декількох полів. Найчастіше така ситуація виникає для таблиці, використовуваної для зв’язування двох таблиць відношенням «багато — до — багатьох».<br />
<img src="db/attachments/Pasted%20image%2020240403094409.png" alt="" /></p>
<h3 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h3>
<p><a href="https://www.postgresql.org/">PostgreSQL</a></p>
<p><img src="db/attachments/Pasted%20image%2020240403094443.png" alt="" /></p>
<p><em><strong>PostgreSQL</strong></em> (вимовляється «Пост-грес-К’ю-ель», або «постгрес») — об’єктно-реляційна система керування базами даних (СКБД).<br />
Сервер PostgreSQL написаний на мові C.</p>
<p><em><strong>Історія</strong></em><br />
PostgreSQL — широко розповсюджена система керування базами даних з відкритим початковим кодом. Прототип був розроблений в Каліфорнійському університеті Берклі в 1987 році під назвою POSTGRES, після чого активно розвивався і доповнювався. В червні 1990 року з’явилась друга версія із переробленою системою правил маніпулювання та роботи з таблицями, у 1991 році — третя версія, із доданою підтримкою одночасної роботи кількох менеджерів збереження, покращеним механізмом запитів і доповненою системою внутрішніх правил. В цей час POSTGRES використовувався для реалізації великих систем, таких як: система аналізу фінансових даних, пакет моніторингу функціональності потоків, база даних відстеження астероїдів, система медичної інформації, кілька географічних систем. POSTGRES також використовувався як навчальний інструмент в кількох університетах. 1992 року POSTGRES став головною СКБД наукового комп’ютерного проєкту Sequoia 2000. 1993 року кількість користувачів подвоїлась. Стало зрозуміло, що для підтримки й подальшого розвитку необхідні великі витрати часу на дослідження баз даних, тому офіційно проєкт Берклі було зупинено на версії 4.2. 1994 року Andrew Yu і Jolly Chen додали інтерпретатор мови SQL, вдосконалили початковий код і виклали в Інтернеті свою реалізацію під назвою Postgres95. 1996 року програмний продукт було перейменовано на PostgreSQL із початковою версією 6.0. Подальшою підтримкою й розробкою займається група спеціалістів у галузі баз даних, які добровільно приєднались до цього проєкту.</p>
<p>Як встановити - <a href="https://github.com/Bandydan/UPostgres/blob/master/psql0.md">Тут</a></p>
<p><a href="https://www.commandprompt.com/education/connecting-postgresql-using-psql-and-pgadmin/">Як підключити PgAdmin 4</a></p>
<h2 id="sql"><a class="header" href="#sql">SQL</a></h2>
<p><strong>SQL</strong> (/ˌɛsˌkjuːˈɛl/ або /ˈsiːkwəl/, англ. <em>Structured query language</em> — мова структурованих запитів) — декларативна мова програмування для взаємодії з базами даних, що застосовується для формування запитів, оновлення і керування реляційними БД, створення схеми бази даних та її модифікації, системи контролю за доступом до бази даних.<br />
Сама по собі SQL не є ані системою керування базами даних, ані окремим програмним продуктом. На відміну від дійсних мов програмування (C або Pascal), SQL може формувати інтерактивні запити або, бувши вбудованою в прикладні програми, виступати як інструкції для керування даними. Окрім цього, стандарт SQL містить функції для визначення зміни, перевірки та захисту даних.</p>
<p>SQL — це діалогова мова програмування для здійснення запиту і внесення змін до бази даних, а також керування базами даних. Багато баз даних підтримує SQL з розширеннями до стандартної мови. Ядро SQL формує командна мова, яка дозволяє здійснювати пошук, вставку, оновлення і вилучення даних за допомогою використання системи керування і адміністративних функцій.</p>
<h3 id="Синтаксис-sql"><a class="header" href="#Синтаксис-sql">Синтаксис SQL</a></h3>
<ul>
<li>
<p>Загальний формат інструкції SQL:</p>
<p>SELECT field_1<br />
FROM table_1<br />
WHERE criterion_1;</p>
</li>
<li>
<p>Ключові слова SQL НЕ чутливі до регістру: <code>select</code> те саме, що і <code>SELECT</code></p>
</li>
<li>
<p>Кожна інструкція закінчується крапкою з комою (;). Вона може стояти як у кінці останнього речення, так і окремо в рядку в кінці інструкції SQL.</p>
</li>
</ul>
<p><strong>Деякі з найважливіших команд SQL</strong></p>
<ul>
<li><code>SELECT</code> - витягує дані з бази даних</li>
<li><code>UPDATE</code> - оновлює дані в базі даних</li>
<li><code>DELETE</code> - видаляє дані з бази даних</li>
<li><code>INSERT INTO</code> - вставляє нові дані в базу даних</li>
<li><code>CREATE DATABASE</code> - створює нову базу даних</li>
<li><code>ALTER DATABASE</code> - змінює базу даних</li>
<li><code>CREATE TABLE</code> - створює нову таблицю</li>
<li><code>ALTER TABLE</code> - змінює таблицю</li>
<li><code>DROP TABLE</code> - видаляє таблицю</li>
<li><code>CREATE INDEX</code> - створює індекс (ключ пошуку)</li>
<li><code>DROP INDEX</code> - видаляє індекс</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Оператор</th><th>Опис</th><th>Приклад</th></tr></thead><tbody>
<tr><td><code>=</code></td><td>дорівнює</td><td><code>Author = 'Alcott'</code></td></tr>
<tr><td><code>&lt;&gt;</code></td><td>не дорівнює (багато СКБД приймають крім <code>&lt;&gt;</code> також <code>!=</code>)</td><td><code>Dept &lt;&gt; 'Sales'</code></td></tr>
<tr><td><code>&gt;</code></td><td>більше ніж</td><td><code>Hire_Date &gt; '2012-01-31'</code></td></tr>
<tr><td><code>&lt;</code></td><td>менше ніж</td><td><code>Bonus &lt; 50000.00</code></td></tr>
<tr><td><code>&gt;=</code></td><td>більше або дорівнює</td><td><code>Dependents &gt;= 2</code></td></tr>
<tr><td><code>&lt;=</code></td><td>менше або дорівнює</td><td><code>Rate &lt;= 0.05</code></td></tr>
<tr><td><code>BETWEEN</code></td><td>між двома величинами включно</td><td><code>Cost BETWEEN 100.00 AND 500.00</code></td></tr>
<tr><td>LIKE</td><td>співставлення тексту з шаблоном</td><td><code>First_Name LIKE 'Will%'</code></td></tr>
<tr><td><code>IN</code></td><td>одне з багатьох можливих значень</td><td><code>DeptCode IN (101, 103, 209)</code></td></tr>
<tr><td><code>IS</code> <em>or</em> <code>IS NOT</code></td><td>Порівняння з null (відсутністю даних)</td><td><code>Address IS NOT NULL</code></td></tr>
<tr><td><code>IS [NOT] TRUE</code> <em>or</em> <code>IS [NOT] FALSE</code></td><td>булева перевірка істинності</td><td><code>PaidVacation IS TRUE</code></td></tr>
<tr><td><code>IS NOT DISTINCT FROM</code></td><td>значення рівні або обоє null (обоє відсутні)</td><td><code>Debt IS NOT DISTINCT FROM - Receivables</code></td></tr>
<tr><td><code>AS</code></td><td>використовується для зміни назви колонки в результаті запиту</td><td><code>SELECT employee AS "department1"</code></td></tr>
</tbody></table>
</div>
<h2 id="Підключення-до-СУБД-postgresql"><a class="header" href="#Підключення-до-СУБД-postgresql">Підключення до СУБД PostgreSQL</a></h2>
<p>Якщо в системі встановлено СУБД PostgreSQL, можна запустити відповідну консольну програму PostgreSQL, яка дозволяє виконувати всі доступні операції з базами даних.</p>
<p>PostgreSQL не вміє працювати без бази даних. Ще до підключення до СУБД PostgreSQL необхідно створити їй базу даних або вибрати одну з існуючих. Для перегляду існуючих баз даних є зовнішня команда консолі:</p>
<pre><code class="language-sh">➜ psql -l
                         List of databases
   Name    | Owner    | Encoding | Collate | Ctype | Access privileges
-----------+-------+----------+---------+-------+-------------------
 postgres  | postgres | UTF8     | C       | C     |
 template0 | postgres | UTF8     | C       | C     | =c/postgres       +
 template1 | postgres | UTF8     | C       | C     | =c/postgres       +
 test      | postgres | UTF8     | C       | C     |
(4 rows)
</code></pre>
<p>Консольна команда для створення бази даних у PostgreSQL.</p>
<pre><code>createdb test
</code></pre>
<p>Після цього підключаємося до неї:</p>
<pre><code class="language-bash">psql test
</code></pre>
<p>Загальний вигляд команди підключення:</p>
<pre><code class="language-bash">psql -U {{ user }} -d {{ dbname }} -h {{ host }}
</code></pre>
<p>Про всяк випадок вкажу команду створення спеціального користувача для роботи з PostgreSQL з усіма можливостями:</p>
<pre><code class="language-sql"># Створення користувача з паролем
CREATE USER postgres WITH SUPERUSER PASSWORD 'password';
# Передача прав на основну настроювальну базу даних новому користувачу ALTER DATABASE postgres OWNER TO postgres;
# (НЕБЕЗПЕЧНО) Видалення користувача, під яким зайшли (НЕБЕЗПЕЧНО)
DROP USER USER_NAME;
</code></pre>
<h3 id="Створення-баз-даних-та-таблиць"><a class="header" href="#Створення-баз-даних-та-таблиць">Створення баз даних та таблиць</a></h3>
<p>Створення своєї бази даних зсередини консолі psql - справа нескладна:</p>
<pre><code class="language-sql">CREATE DATABASE test;
</code></pre>
<p>База створена. Підключемося до неї:</p>
<pre><code class="language-sql">\c test
You are now connected to database "test" as user "postgres".
</code></pre>
<pre><code class="language-sql">CREATE TABLE cars(id SERIAL PRIMARY KEY, brand TEXT NOT NULL);
</code></pre>
<p><a href="https://www.tutorialspoint.com/postgresql/postgresql_data_types.htm">Типи даних у PostgreSQL</a></p>
<p>Окремо про <a href="https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-serial/">SERIAL</a><br />
Важливо зазначити, що <code>SERIAL</code> не створює неявно індекс для стовпця та не робить стовпець стовпцем первинного ключа. Однак це можна легко зробити, вказавши обмеження <code>PRIMARY KEY</code> для стовпця <code>SERIAL</code>.</p>
<p>Для того, щоб подивитися список таблиць, використовуйте команду <code>\dt</code> або <code>\dt+</code></p>
<pre><code class="language-sh">postgresdb-# \dt
        List of relations
Schema | Name | Type  |    Owner
--------+------+-------+--------------
public | cars | table | postgres
(1 row)
</code></pre>
<p>Подивимося на результуючу таблицю:</p>
<pre><code class="language-sh">\d cars
                            Table "public.cars"
 Column |  Type   | Collation | Nullable |             Default
--------+---------+-----------+----------+----------------------------------
 id     | integer |           | not null | nextval('cars_id_seq'::regclass)
 brand  | text    |           | not null |
</code></pre>
<p>Команда <code>\d</code> (скорочення від <code>describe</code>) з ім’ям таблиці виводить короткий опис таблиці.</p>
<h3 id="Редагування-таблиці"><a class="header" href="#Редагування-таблиці">Редагування таблиці</a></h3>
<p>Для зміни існуючої таблиці є команда <code>alter table</code>:</p>
<p><strong>Додати стовпець</strong></p>
<pre><code class="language-sh">ALTER TABLE cars add column model varchar(100) not null;
ALTER TABLE

\d cars
                                    Table "public.cars"
 Column |          Type          | Collation | Nullable |             Default
--------+------------------------+-----------+----------+----------------------------------
 id     | integer                |           | not null | nextval('cars_id_seq'::regclass)
 brand  | text                   |           | not null |
 model  | character varying(100) |           | not null |
</code></pre>
<p>Ми додали до таблиці машин колонку із моделлю машини, використавши команду <code>alter table</code>. Тим самим шляхом видалимо цю колонку:</p>
<p><strong>Видалити стовпець</strong></p>
<pre><code class="language-sh">alter table cars drop column model;
ALTER TABLE
\d cars
                            Table "public.cars"
 Column |  Type   | Collation | Nullable |             Default
--------+---------+-----------+----------+----------------------------------
 id     | integer |           | not null | nextval('cars_id_seq'::regclass)
 brand  | text    |           | not null |
</code></pre>
<p><strong>Перейменувати стовпець</strong></p>
<p>Щоб перейменувати стовпець у таблиці, використовуйте наведений нижче синтаксис:</p>
<pre><code class="language-sh">ALTER  TABLE  table_name 
RENAME  COLUMN  old_name  to  new_name;
</code></pre>
<p>Команда <a href="http://www.postgresqltutorial.com/postgresql-alter-table/">alter table</a> досить складна, але багато що дозволяє. Команда, як і при створенні таблиці, дозволяє додавати і видаляти колонки, змінювати їх різними способами, додавати на них різні індекси, вішати ключі на таблиці і видаляти їх і так далі.</p>
<h3 id="Видалення-таблиці"><a class="header" href="#Видалення-таблиці">Видалення таблиці</a></h3>
<p>Для видалення таблиць є дві цікаві команди:<br />
<code>drop table</code> з ім’ям таблиці просто видаляє таблицю.</p>
<pre><code class="language-sh">DROP TABLE cars;

</code></pre>
<p><code>truncate table</code> з ім’ям таблиці видаляє лише вміст таблиці, не змінюючи її структури. Serial, якщо він є, зберігатиме своє значення, але є можливість скинути його в нуль, додавши параметр <code>RESTART IDENTITY</code>:</p>
<pre><code class="language-sh">TRUNCATE fattable RESTART IDENTITY;
</code></pre>
<p>База даних видаляється командою <code>drop database</code> з ім’ям таблиці та крапкою коми в кінці.</p>
<h2 id="crud-даних"><a class="header" href="#crud-даних">CRUD даних</a></h2>
<p><img src="db/attachments/Pasted%20image%2020240403101617.png" alt="" /></p>
<p>Коли база даних створена та таблиці в ній створені, коли все це зроблено правильним користувачем з правильними правами та рівнем доступу, саме час заповнити таблиці даними.<br />
У роботі з даними є лише 4 дії: створення, отримання, зміна та видалення даних. Для позначення цих процесів використовується абревіатура</p>
<p><strong>CRUD: Create, Read, Update, Delete</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>CRUD</th><th>SQL</th></tr></thead><tbody>
<tr><td>Create</td><td>INSERT</td></tr>
<tr><td>Read</td><td>SELECT</td></tr>
<tr><td>Update</td><td>UPDATE</td></tr>
<tr><td>Delete</td><td>DELETE</td></tr>
</tbody></table>
</div>
<p>Для експериментів із даними нам знадобиться таблиця. Наприклад, таблиця слів зі словника та таблиця словників. Про всяк випадок - команди створення цих таблиць та їх опис:</p>
<pre><code class="language-sql">CREATE TABLE vocabulary  
(  
    id SERIAL PRIMARY KEY,  
    name VARCHAR(255),  
    info TEXT  
);  
  
CREATE TABLE word  
(  
    id SERIAL PRIMARY KEY,  
    word VARCHAR(255),  
    vocabulary_id INTEGER REFERENCES vocabulary(id)  
);

\d vocabulary
                                    Table "public.vocabulary"
 Column |          Type          | Collation | Nullable |                Default
--------+------------------------+-----------+----------+----------------------------------------
 id     | integer                |           | not null | nextval('vocabulary_id_seq'::regclass)
 name   | character varying(255) |           |          |
 info   | text                   |           |          |

\d word
                                       Table "public.word"
    Column     |          Type          | Collation | Nullable |             Default
---------------+------------------------+-----------+----------+----------------------------------
 id            | integer                |           | not null | nextval('word_id_seq'::regclass)
 word          | character varying(255) |           |          |
 vocabulary_id | integer                |           |          |

</code></pre>
<h3 id="create---додавання-даних-insert"><a class="header" href="#create---додавання-даних-insert">Create - додавання даних: INSERT</a></h3>
<p>Для додавання даних до таблиці використовується оператор <strong><code>INSERT INTO</code></strong>. Оператор <strong><code>INSERT INTO</code></strong> буває декількох видів, і ми розглянемо основні:</p>
<h3 id="simple-insert"><a class="header" href="#simple-insert">Simple insert</a></h3>
<p>Найпростіший варіант вставки даних у таблицю виглядає так:</p>
<pre><code class="language-sh">insert into vocabulary (name) values ('verbs');
INSERT 0 1
</code></pre>
<p>Перевіримо наші дані найпростішим <strong><code>select</code></strong>:</p>
<pre><code class="language-sql">select * from vocabulary;
 id |          name           | info
----+-------------------------+------
  1 | verbs                   |
(1 row)
</code></pre>
<p>У цьому прикладі ми вставляємо запис в таблицю vocabulary, вказуючи конкретне значення для кожного стовпця.</p>
<h3 id="multiple-insert"><a class="header" href="#multiple-insert">Multiple insert</a></h3>
<pre><code class="language-sql">insert into vocabulary (name) values ('IT'), ('Silicon Valley season 1');
INSERT 0 2
</code></pre>
<p>Перевіримо:</p>
<pre><code class="language-sql">select * from vocabulary;

 id |          name           | info
----+-------------------------+------
  1 | verbs                   |
  2 | IT                      |
  3 | Silicon Valley season 1 |
(3 rows)
</code></pre>
<p>Код вставляє дані в наступних дужках у відповідні стовпці, зазначені в перших дужках. Таким чином, спочатку необхідно перерахувати стовпці (поля), в які планується вносити дані, а потім через кому перерахувати обгорнуті дужками набори даних для цих полів. Такий запит дозволяє додавати кілька записів разом.</p>
<h3 id="insert-from-select"><a class="header" href="#insert-from-select">Insert from select</a></h3>
<p>Можлива також вставка даних із результату запиту:</p>
<pre><code class="language-sql">insert into vocabulary select * from vocabulary;
INSERT 0 3

select * from vocabulary;

 id |          name           | info
----+-------------------------+------
  1 | verbs                   |
  2 | IT                      |
  3 | Silicon Valley season 1 |
  1 | verbs                   |
  2 | IT                      |
  3 | Silicon Valley season 1 |
(6 rows)
</code></pre>
<p>Тут наведено досить простий приклад, але, по суті, якщо ви збудуєте запит даних <code>SELECT</code>таким чином, щоб кількість стовпців в результаті відповідала необхідному, вказаному в зовнішньому запиті <code>INSERT</code>**, ви можете вбудувати запит досить серйозного рівня складності.</p>
<h3 id="read---вибірка-даних-select"><a class="header" href="#read---вибірка-даних-select">Read - вибірка даних: SELECT</a></h3>
<p>Запит <strong><code>SELECT</code></strong> використовується для отримання даних, і жодним чином їх не змінює. Структура його досить складна, і спробуємо розібрати її поступово і поетапно.</p>
<p>Мінімальний можливий запит має такий вигляд:</p>
<pre><code class="language-sql">select 1;
 ?column? 
----------
        1
(1 row)

</code></pre>
<p>Єдиним обов’язковим ключовим словом у запиті <strong><code>select</code></strong> є слово <code>SELECT</code> - вибрати.</p>
<p>Після цього слова слід писати:</p>
<ul>
<li>функції та оператори PostgreSQL (<a href="https://www.tutorialspoint.com/postgresql/postgresql_date_time.htm">наприклад, функції роботи з датою та часом</a>)</li>
</ul>
<pre><code class="language-sql">select CURRENT_TIME;

    current_time
--------------------
 16:54:45.183026+03
(1 row)
</code></pre>
<ul>
<li>рядки та числа</li>
<li>поля таблиць, тимчасових таблиць та уявлень, які ми збираємося вибирати</li>
<li>похідні від цих полів</li>
<li>Вирази</li>
</ul>
<p>Найчастіше <strong><code>SELECT</code></strong> використовується для роботи з даними з таблиць, і для цього потрібно вказати ці таблиці. Таблиці, якими здійснюється вибірка, перераховуються після ключового слова <strong><code>FROM</code></strong>:</p>
<pre><code class="language-sql">SELECT * FROM books;
</code></pre>
<p>Наведений вище запит вибирає всі поля (за це відповідає зірочка) із таблиці books.
Максимально докладна схема запиту <code>select</code> виглядає так:</p>
<pre><code class="language-sql">SELECT
    &lt;field1&gt;,
    &lt;field2&gt;,
    &lt;field3&gt;
    ...
FROM
    &lt;table1&gt;,
    &lt;table2&gt;,
    &lt;joins&gt;,
    &lt;views&gt;,
    &lt;temp_table&gt;
    ...
WHERE
    &lt;cond&gt;
    
ORDER BY
    &lt;field1&gt; ASC
    &lt;field3&gt; DESC
GROUP BY
    &lt;field 1&gt;
HAVING
    &lt;cond with aggr function&gt;
LIMIT
    N,M
</code></pre>
<p>Нижче наведений текстовий опис основних елементів структури запиту <strong><code>SELECT</code></strong>, докладніший опис з прикладами буде наведено пізніше.</p>
<ol>
<li>Після ключового слова <strong><code>SELECT</code></strong> йде перелік полів таблиць, функцій, що обчислюються з цих полів, констант, незалежних від записів функцій. Для вказівки всіх полів використовується зірочка. Цей пункт є єдиним обов’язковим пунктом у запиті <strong><code>SELECT</code></strong>, інші опціональні.</li>
<li>Далі, після ключового слова <strong><code>FROM</code></strong> слідує перелік таблиць, уявлень та тимчасових таблиць, звідки ведеться вибірка. Таблиці можуть бути перераховані, а можуть бути приєднані до інших таблиць за описаними окремо правил, тобто. за допомогою <strong><code>JOIN</code></strong>.</li>
<li>Далі слідує умова <strong><code>WHERE</code></strong>, що пропускає лише ті записи, які задовольняють перерахованим у <strong><code>WHERE</code></strong> умовам. Всі записи, що не пройшли перевірку, відфільтровуються і не демонструються.</li>
<li>Після фільтру <strong><code>WHERE</code></strong> може слідувати групування записів.</li>
<li>Угруповання виконується за допомогою ключових слів <strong><code>GROUP BY</code></strong>. Суть угруповання в тому, що записи можуть об’єднуватися за ознакою або декількома ознаками в один запис, який несе у собі якусь загальну для всіх записів групи інформацію або результат обробки інформації по всій групі. Конструкція <strong><code>GROUP BY</code></strong> може включати ключове слово <strong><code>HAVING</code></strong>, що дозволяє фільтрувати результати груповання.</li>
<li>Важливо відзначити, що груповання дозволяє використовувати аггрегатні функції як в <strong><code>HAVING</code></strong>, так і після <strong><code>SELECT</code></strong>.</li>
<li>Після групування може відбутися сортування записів за допомогою ключових слів <strong>ORDER BY</strong>. При групуванні вказується поле або перелік полів, за яким необхідно відсортувати, також можна вказати напрямок сортування. За умовчанням здійснюється сортування за зростанням <code>ASC</code>. Сортування за спаданням здійснюється за допомогою ключового слова <strong><code>DESC</code></strong>.</li>
<li>Наприкінці запиту можливе додавання обмежень на кількість записів. Слово <strong><code>LIMIT</code></strong> та цифрою після вказує, скільки записів ви хочете бачити в результаті. Якщо після слова <strong><code>LIMIT</code></strong> написати <code>OFFSET</code> і цифру. -можна пропустити частину записів <strong><code>LIMIT 20 OFFSET 5</code></strong> пропустить 5 записів та покаже вам 20 наступних.</li>
<li>PostgreSQL надає альтернативу LIMIT - <strong><code>FETCH</code></strong>. На думку розробників, <strong><code>FETCH</code></strong> краще відповідає стандартам SQL мови.</li>
</ol>
<h3 id="Практика-з-select-та-insert"><a class="header" href="#Практика-з-select-та-insert">Практика з SELECT та INSERT</a></h3>
<h3 id="distinct"><a class="header" href="#distinct">DISTINCT</a></h3>
<pre><code class="language-sql">select * from vocabulary;
 id |          name           | info
----+-------------------------+------
  1 | verbs                   |
  2 | IT                      |
  3 | Silicon Valley season 1 |
  1 | verbs                   |
  2 | IT                      |
  3 | Silicon Valley season 1 |
(6 rows)

select distinct * from vocabulary;
 id |          name           | info
----+-------------------------+------
  2 | IT                      |
  1 | verbs                   |
  3 | Silicon Valley season 1 |
(3 rows)
</code></pre>
<p>Умова <strong><code>DISTINCT</code></strong> відкидає дублікати в результаті запиту, залишаючи лише унікальні записи.</p>
<h3 id="where"><a class="header" href="#where">WHERE</a></h3>
<p>Додамо кілька слів до нашої таблиці слів:</p>
<pre><code class="language-sql">insert into word (word, vocabulary_id) values('have', 1), ('IP', 2), ('Kanban', 3);
INSERT 0 3

insert into word (word, vocabulary_id) values('have', 7), ('TCP/IP', 2), ('Function', 3);
INSERT 0 3
</code></pre>
<p>Тепер виберемо всі слова та кілька разів відфільтруємо їх за допомогою <strong><code>where</code></strong>:</p>
<pre><code class="language-sql">select * from word;
 id |   word   | vocabulary_id
----+----------+---------------
  1 | have     |             1
  2 | IP       |             2
  3 | Kanban   |             3
  4 | have     |             7
  5 | TCP/IP   |             2
  6 | Function |             3
(6 rows)

select word from word where id &gt; 5;
   word
----------
 Function
(1 row)

select word from word where id &gt; 3;
   word
----------
 have
 TCP/IP
 Function
(3 rows)
</code></pre>
<p>Трохи більше фільтрації та перерахування полів:</p>
<pre><code class="language-sql">select word from word where vocabulary_id &lt; 4 and id &lt; 6;
  word
--------
 have
 IP
 Kanban
 TCP/IP
(4 rows)

select id, word, vocabulary_id from word where vocabulary_id &lt; 4 and id &lt; 6;
 id |  word  | vocabulary_id
----+--------+---------------
  1 | have   |             1
  2 | IP     |             2
  3 | Kanban |             3
  5 | TCP/IP |             2
(4 rows)
</code></pre>
<p>Умови можна комбінувати за допомогою <code>AND</code> та <code>OR</code>.</p>
<h3 id="group-by"><a class="header" href="#group-by">GROUP BY</a></h3>
<p>Групувати можна дані, які повторюються у групах і не суперечитимуть умовам угруповання. При групуванні можна логічно використовувати агрегатні функції. Агрегатні функції - особливі функції SQL, які застосовуються до всіх записів в результатів вибірки, або до груп.<br />
<code>COUNT</code> – одна з таких функцій.<br />
Більше агрегатних функції <a href="https://krypton.com.ua/rozdil-4-zapyty/agregatni-funkcziyi/">тут</a> (SUM, MIN, MAX)</p>
<pre><code class="language-sql">select vocabulary_id from word where vocabulary_id &lt; 4 
and id &lt; 6 group by vocabulary_id;
 vocabulary_id
---------------
             3
             1
             2
(3 rows)

select count(*), vocabulary_id from word where vocabulary_id &lt; 4
and id &lt; 6 group by vocabulary_id;
 count | vocabulary_id
-------+---------------
     1 |             3
     1 |             1
     2 |             2
(3 rows)
</code></pre>
<h3 id="group-by---having"><a class="header" href="#group-by---having">GROUP BY - HAVING</a></h3>
<p>Ключове слово <code>HAVING</code> додається лише після <code>GROUP BY</code> для додаткової фільтрації результатів запиту. <code>WHERE</code> фільтрує їх до угруповання, <code>HAVING</code> фільтрує згруповані.</p>
<pre><code class="language-sql">select count(*), vocabulary_id from word where vocabulary_id &lt; 4
and id &lt; 6 group by vocabulary_id having count(*) &gt; 1;

 count | vocabulary_id
-------+---------------
     2 |             2
(1 row)
</code></pre>
<p>У цьому запиті відображаються лише ті групи слів, які зустрілися більше одного разу.</p>
<h3 id="order-by"><a class="header" href="#order-by">ORDER BY</a></h3>
<p>Окрім сортування за зростанням <code>ASC</code> або спаданням <code>DESC</code>, можна ще вказувати, за яким полем це робити. Поле можна прописати як за назвою, так і номером за порядком.</p>
<pre><code class="language-sql">select * from word order by vocabulary_id;
 id |   word   | vocabulary_id
----+----------+---------------
  1 | have     |             1
  2 | IP       |             2
  5 | TCP/IP   |             2
  3 | Kanban   |             3
  6 | Function |             3
  4 | have     |             7
(6 rows)

select * from word order by 3;
 id |   word   | vocabulary_id
----+----------+---------------
  1 | have     |             1
  2 | IP       |             2
  5 | TCP/IP   |             2
  3 | Kanban   |             3
  6 | Function |             3
  4 | have     |             7
(6 rows)

select * from word order by 3, 2;
 id |   word   | vocabulary_id
----+----------+---------------
  1 | have     |             1
  2 | IP       |             2
  5 | TCP/IP   |             2
  6 | Function |             3
  3 | Kanban   |             3
  4 | have     |             7
(6 rows)
</code></pre>
<h3 id="limit-и-offset"><a class="header" href="#limit-и-offset">LIMIT и OFFSET</a></h3>
<pre><code class="language-sql">select * from word order by 3, 2 limit 3;
 id |  word  | vocabulary_id
----+--------+---------------
  1 | have   |             1
  2 | IP     |             2
  5 | TCP/IP |             2
(3 rows)

select * from word order by 3, 2 limit 3 offset 3;
 id |   word   | vocabulary_id
----+----------+---------------
  6 | Function |             3
  3 | Kanban   |             3
  4 | have     |             7
(3 rows)
</code></pre>
<p><strong>Зверніть увагу!</strong><br />
<code>UPDATE</code> та <code>DELETE</code> виконувати з <code>WHERE</code> (умовою).<br />
Без цього оновляться чи видаляться усі записи!</p>
<h3 id="update---update"><a class="header" href="#update---update">Update - UPDATE</a></h3>
<p>Якщо треба оновити дані, використовуємо <code>UPDATE</code><br />
Загальний вигляд:</p>
<pre><code class="language-sql">UPDATE table_name SET column1 = value1, column2 = value2_, ... WHERE condition;
</code></pre>
<pre><code class="language-sql">UPDATE  word  
SET  word = 'Agile'  
WHERE  id = 3;
</code></pre>
<h3 id="delete---delete"><a class="header" href="#delete---delete">Delete - DELETE</a></h3>
<p>Для видалення використовуємо <code>DELETE</code><br />
Загальний вигляд:</p>
<pre><code class="language-sql">DELETE  FROM  table_name 
WHERE  condition;
</code></pre>
<pre><code class="language-sql">DELETE FROM word WHERE id = 6;
</code></pre>
<h2 id="Домашнє-завдання"><a class="header" href="#Домашнє-завдання">Домашнє завдання:</a></h2>
<p>Результати напрацювань заливаємо на Github так, щоб можна було легко знайти їх за номером уроку.<br />
Розширення файлу .sql<br />
У якому і будуть запити один за одним</p>
<ol start="0">
<li>Встановити PostgreSQL</li>
<li>Практикуємо все, що пройдено на уроці.</li>
<li>Cтворити базу даних фільмів із таблицями акторів, фільмів, режисерів.</li>
<li>Додати дані в таблицях.</li>
<li>Додатково ознайомитися з FETCH (аналог LIMIT) та TRUNCATE (аналог DROP TABLE + CREATE TABLE)</li>
</ol>
<h2 id="Література"><a class="header" href="#Література">Література:</a></h2>
<ol start="0">
<li>📖 <a href="https://krypton.com.ua/vvedenye-v-postgresql/">Введення в PostgreSQL</a></li>
<li>📖 <a href="https://w3schoolsua.github.io/sql/index.html#gsc.tab=0">SQL Підручник</a></li>
<li>📖 <a href="https://sqlzoo.net/wiki/SQL_Tutorial">SQL Tutorial</a></li>
<li>🎥 <a href="https://www.khanacademy.org/computing/computer-programming/sql/sql-basics/v/welcome-to-sql">SQL basics</a></li>
<li><a href="https://www.postgresql.org/docs/current/app-psql.html#APP-PSQL-META-COMMANDS">Метакоманди типу <code>\q</code>:</a></li>
<li><a href="https://krypton.com.ua/rozdil-4-zapyty/agregatni-funkcziyi/">Агрегатні функції</a></li>
<li><a href="http://www.postgresqltutorial.com/postgresql-fetch/">FETCH</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p><a href="db/12-postgresql-join.excalidraw.html">12-postgresql-join.excalidraw</a></p>
<h1 id="posgresql-відносини-складні-запити-join"><a class="header" href="#posgresql-відносини-складні-запити-join">PosgreSQL, відносини, складні запити, JOIN</a></h1>
<h1 id="Зміст-1"><a class="header" href="#Зміст-1">Зміст</a></h1>
<ul>
<li><a href="db/12-postgresql-join.html#%D0%92%D0%B8%D0%B4%D0%B8-%D0%BB%D0%BE%D0%B3%D1%96%D1%87%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B7%D0%B2%D1%8F%D0%B7%D0%BA%D1%83-%D0%B2%D1%96%D0%B4%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%BD%D1%8F-%D0%BC%D1%96%D0%B6-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8F%D0%BC%D0%B8">Види логічного зв’язку (відношення між таблицями)</a></li>
<li><a href="db/12-postgresql-join.html#%D0%9E%D0%B1%D1%94%D0%B4%D0%BD%D0%B0%D0%BD%D0%BD%D1%8F-joins">Об’єднання (JOINS)</a>
<ul>
<li><a href="db/12-postgresql-join.html#case"><code>CASE</code></a></li>
<li><a href="db/12-postgresql-join.html#%D0%9A%D0%BE%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D1%96">Коментарі</a></li>
</ul>
</li>
<li><a href="db/12-postgresql-join.html#%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0">Практика</a></li>
<li><a href="db/12-postgresql-join.html#%D0%94%D0%BE%D0%BC%D0%B0%D1%88%D0%BD%D1%94-%D0%B7%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F">Домашнє завдання:</a></li>
<li><a href="db/12-postgresql-join.html#%D0%9B%D1%96%D1%82%D0%B5%D1%80%D0%B0%D1%82%D1%83%D1%80%D0%B0-%D1%82%D0%B0-%D0%9A%D0%BE%D1%80%D0%B8%D1%81%D0%BD%D1%96-%D0%BF%D0%BE%D1%81%D0%B8%D0%BB%D0%B0%D0%BD%D0%BD%D1%8F">Література та Корисні посилання</a></li>
</ul>
<h2 id="Види-логічного-звязку-відношення-між-таблицями"><a class="header" href="#Види-логічного-звязку-відношення-між-таблицями">Види логічного зв’язку (відношення між таблицями)</a></h2>
<p>Зв’язок встановлюється між двома загальними полями (стовпцями) двох таблиць.</p>
<p>Відносини, які можуть існувати між записами двох таблиць:</p>
<ol>
<li><strong>One-to-one</strong> (1:1) <em><strong>один-до-одного</strong></em> — кожному запису з однієї таблиці відповідає один запис у іншій таблиці; створюється в тому випадку, коли обидва поля є ключовими або мають унікальні індекси.  <img src="db/attachments/Pasted%20image%2020240403102811.png" alt="" /></li>
<li><strong>One-to-many</strong> (1:N) <em><strong>один-до-багатьох</strong></em> — кожному запису з однієї таблиці відповідає кілька записів у іншій таблиці; створюється в тому випадку, коли тільки одне з полів є полем первинного ключа або унікального індексу.  <em><strong>багато-до-одного</strong></em> — безлічі записів з однієї таблиці відповідає один запис у іншій таблиці;<img src="db/attachments/Pasted%20image%2020240403102852.png" alt="" /></li>
<li><strong>Many-to-many</strong> (N:N) <em><strong>багато-до-багатьох</strong></em> — безліч записів з однієї таблиці відповідає кілька записів в іншій таблиці; фактично є двома відносинами «один-до-багатьох» з третьої таблицею, первинний ключ якої складається з полів зовнішнього ключа двох інших таблиць. <img src="db/attachments/Pasted%20image%2020240403102909.png" alt="" /></li>
</ol>
<p><img src="db/attachments/Pasted%20image%2020240403102919.png" alt="" /></p>
<h2 id="Обєднання-joins"><a class="header" href="#Обєднання-joins">Об’єднання (JOINS)</a></h2>
<p><img src="db/attachments/Pasted%20image%2020240403102927.png" alt="" /></p>
<p>Запити до однієї таблиці досить рідкісні. Найчастіше запити до баз даних пишуться з метою отримати інформацію з кількох таблиць, інформація з яких поєднується за певними умовами.</p>
<p><img src="db/attachments/Pasted%20image%2020240403102936.png" alt="" /></p>
<p>Створимо таблиці авторів, книг, жанрів та таблицю зв’язків для авторів та книг (Many-to-many):</p>
<pre><code class="language-sql">CREATE TABLE authors  
(  
    id SERIAL PRIMARY KEY,  
    name VARCHAR(200) NOT NULL,  
    year DATE         NOT NULL DEFAULT '1970-01-01'  
);  
  
CREATE TABLE genres  
(  
    id SERIAL PRIMARY KEY,  
    genre VARCHAR(100) NOT NULL  DEFAULT 0
);  
  
CREATE TABLE books  
(  
    id SERIAL PRIMARY KEY,  
    title VARCHAR(200) NOT NULL,  
    genre_id INT          NOT NULL REFERENCES genres (id)  
);  
  
  
CREATE TABLE authors_books  
(  
    id SERIAL PRIMARY KEY,  
    author_id INT NOT NULL REFERENCES authors (id),  
    book_id INT NOT NULL REFERENCES books (id)  
);
</code></pre>
<p>Далі слід заповнити таблицю даними:</p>
<pre><code class="language-sql">INSERT INTO genres (genre) VALUES
	('SF'),
	('novel'),
	('story'),
	('horror');

INSERT INTO books(title, genre_id) VALUES
	('Майстер і Маргарита', 2),
	('Фауст', 0),
	('Білий клик', 3),
	('Дюна', 1),
	('Острів скарбів', 2),
	('Залізна п''ята', 3),
	('Дракон у морі', 1);

INSERT INTO authors (name) VALUES
	('Френк Герберт'),
	('Михайло Булгаков'), 
	('Джек Лондон'), 
	('Йоган Ґете'), 
	('Роберт Хайнлайн');

INSERT INTO authors_books (author_id, book_id) VALUES 
	(1, 4),
	(1, 7),
	(2, 1),
	(3, 3),
	(3, 6),
	(4, 2);
</code></pre>
<p>Дані готові, тепер можна вивчати об’єднання таблиць. Почнемо ми з об’єднання двох таблиць в одному запиті:</p>
<pre><code class="language-sql">SELECT title, genre
FROM books
INNER JOIN genres ON (genres.id = books.genre_id);

       title         | genre
---------------------+-------
 Майстер і Маргарита | novel
 Білий клик          | story
 Дюна                | SF
 Острів скарбів      | novel
 Залізна п'ята       | story
 Дракон у морі       | SF
(6 rows)

</code></pre>
<ul>
<li>Для відображення назви колонок на кількості рядків треба виконати команду <code>\t</code></li>
</ul>
<p><strong><code>INNER JOIN</code></strong> виводить записи з лівої таблиці (першої з двох таблиць, які він об’єднує), для яких знайдеться відповідний запис у правій (другій та останній у списку) таблиці. Якщо відповідності у правій таблиці немає, такий запис не виводиться. В даному випадку можна бачити, що запис про книгу “Фауст” не виводиться. Це відбувається через те, що <code>genre_id</code> цей запис дорівнює нулю, а такого жанру в таблиці жанрів немає.<br />
Так само в результат не потрапляє жанр horror, тому що немає жодної книги з таким жанром.</p>
<pre><code class="language-sql">SELECT title, genre
FROM books
LEFT JOIN genres ON (genres.id = books.genre_id);

       title         | genre
---------------------+-------
 Майстер і Маргарита | novel
 Фауст               |
 Білий клик          | story
 Дюна                | SF
 Острів скарбів      | novel
 Залізна п'ята       | story
 Дракон у морі       | SF
(7 rows)

</code></pre>
<p><strong><code>LEFT JOIN</code></strong> виводить <strong>ВСІ</strong> записи з лівої таблиці. Для тих записів, яким знаходиться відповідність у правій, він, аналогічно <strong>INNER JOIN</strong>, виведе відповідні дані з другої таблиці. Для тих, яким відповідності не знайшлося, він нічого не виведе в стовпцях правої таблиці, залишивши їх порожніми.</p>
<p>Щоб визначити, яким книгам не знайдені у відповідність жанри, можна виконати запит із підзапитом:</p>
<pre><code class="language-sql">SELECT title
FROM books
WHERE NOT EXISTS (
	SELECT * 
	FROM genres 
	WHERE books.genre_id = genres.id
);

 title
-------
 Фауст
(1 row)
</code></pre>
<p>Цей шлях вважається правильнішим, ніж класичний:</p>
<pre><code class="language-sql">SELECT title, genre 
FROM books 
LEFT JOIN genres ON (genres.id = books.genre_id)
WHERE genre IS NULL;


 title| genre
 -----+-------
 Фауст | NULL
(1 row)

</code></pre>
<p><strong><code>RIGHT JOIN</code></strong> надходить аналогічним чином з правою таблицею: виводить усі записи з неї, додаючи записи з лівої. Де відповідності немає, залишає в стовпцях лівої таблиці порожнечу.</p>
<pre><code class="language-sql">SELECT title, genre
FROM books
RIGHT JOIN genres ON (genres.id = books.genre_id);

       title         | genre
---------------------+--------
 Майстер і Маргарита | novel
 Білий клик          | story
 Дюна                | SF
 Острів скарбів      | novel
 NULL                | horror
(5 rows)
</code></pre>
<p>Якщо у вас виникне потреба побачити всі книги та всі жанри незалежно від наявності відповідних записів в іншій таблиці, але де зв’язки є – зв’язати таблиці, можна об’єднати результати двох запитів за допомогою <code>UNION</code>:</p>
<pre><code class="language-sql">SELECT title, genre 
FROM books 
LEFT JOIN genres ON (genres.id = books.genre_id) 
UNION 
SELECT title, genre 
FROM books RIGHT JOIN genres ON (genres.id = books.genre_id);


       title         | genre
---------------------+--------
 Фауст               | NULL
 NULL                | horror
 Острів скарбів      | novel
 Білий клик          | story
 Дюна                | SF
 Майстер і Маргарита | novel
(6 rows)
</code></pre>
<p>Аналогічного результату можна досягти і спеціальним видом об’єднань - <strong><code>FULL JOIN</code></strong>:</p>
<pre><code class="language-sql">SELECT title, genre
FROM books
FULL JOIN genres ON (genres.id = books.genre_id);


       title         | genre
---------------------+--------
 Майстер і Маргарита | novel
 Фауст               | NULL
 Білий клик          | story
 Дюна                | SF
 Острів скарбів      | novel
 NULL                | horror 
(6 rows)
</code></pre>
<p>Якщо поля зв’язку називаються однаково, наприклад, поле <code>id</code> у таблиці <code>genres</code> називається <code>genre_id</code>, запит можна трохи спростити. Для демонстрації перейменуємо поле та виконаємо цей запит:</p>
<pre><code class="language-sql">ALTER TABLE genres RENAME COLUMN id TO genre_id;


SELECT title, genre
FROM books 
RIGHT JOIN genres USING(genre_id);


       title         | genre
---------------------+--------
 Майстер і Маргарита | novel
 Білий клик          | story
 Дюна                | SF
 Острів скарбів      | novel
 Залізна п'ята       | story
 Дракон у морі       | SF
                     | horror                     
(7 rows)

</code></pre>
<h3 id="case"><a class="header" href="#case"><code>CASE</code></a></h3>
<p>Вираз <code>CASE</code> перевіряє умови та повертає значення, коли виконується перша умова (наприклад, інструкція if-then-else). Отже, як тільки умова виконується, вона припинить читання та поверне результат. Якщо жодна умова не виконується, повертається значення в пропозиції <code>ELSE</code>.<br />
<a href="https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-case/">Детальніше</a></p>
<p>Якщо немає частини <code>ELSE</code> і немає умов, повертає NULL.</p>
<p>Результат буде той же, що і у звичайного <code>RIGHT JOIN</code> запиту, але сам запит коротше.</p>
<p><strong>Синтаксис</strong></p>
<pre><code class="language-sql">CASE
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    WHEN conditionN THEN resultN
    ELSE result
END;
</code></pre>
<pre><code class="language-sql">SELECT name,
CASE 
	WHEN COUNT(book_id) = 0 THEN 'None' 
ELSE CAST(COUNT(book_id) as varchar)
END as book_count
FROM authors
LEFT JOIN authors_books ON (authors.id = authors_books.author_id)
GROUP BY name;

       name       | book_count
------------------+------------
 Роберт Хайнлайн  | None
 Михайло Булгаков | 1
 Йоган Ґете       | 1
 Джек Лондон      | 2
 Френк Герберт    | 2
(5 rows)

</code></pre>
<h3 id="Коментарі"><a class="header" href="#Коментарі">Коментарі</a></h3>
<p><em>Коментарі</em> — це рядки тексту в коді, які допомагають усім, хто його читає, краще зрозуміти, що й навіщо робить код. Коментарі повністю ігноруються (тобто не виконуються) системами управління базами даних (СУБД).</p>
<p><strong>Однорядкові коментарі</strong><br />
У SQL подвійне тире <code>--</code> використовується для написання однорядкового коментаря.</p>
<pre><code class="language-sql">-- Отримання всіх даних з таблиці Students
SELECT *
FROM Students;
</code></pre>
<p><strong>Коментарі на одному рядку з кодом</strong><br />
Також можна писати коментарі на одному рядку із SQL-командами. Наприклад:</p>
<pre><code class="language-sql">SELECT * -- вибираємо всі дані
FROM Students; -- з таблиці Students
</code></pre>
<p><strong>Багаторядкові коментарі</strong><br />
В SQL багаторядкові коментарі починаються з /* і закінчуються */. Наприклад:</p>
<pre><code class="language-sql">/* Вибираємо всі дані
з таблиці Students */
SELECT *
FROM Students;
</code></pre>
<p><strong>Коментарі всередині рядків коду</strong><br />
Подібно до однорядкових коментарів, багаторядкові коментарі можна поміщати безпосередньо в рядки SQL-коду. Наприклад:</p>
<pre><code class="language-sql">SELECT *
FROM /* тут ім'я таблиці */ Students;
</code></pre>
<h2 id="Практика"><a class="header" href="#Практика">Практика</a></h2>
<ol>
<li>Об’єднати авторів із назвами книг за допомогою таблиці зв’язків</li>
<li><a href="https://github.com/pthom/northwind_psql">https://github.com/pthom/northwind_psql</a></li>
</ol>
<pre><code class="language-sql">CREATE TABLE authors_books_1 (
	id SERIAL PRIMARY KEY,
	author_id INT NOT NULL DEFAULT 0,
	book_id INT NOT NULL DEFAULT 0,
	CONSTRAINT fk_books
	 FOREIGN KEY(book_id) 
	  REFERENCES books(id)
	   ON DELETE CASCADE, 
	CONSTRAINT fk_author
	 FOREIGN KEY(author_id) 
	  REFERENCES authors(id)
	   ON DELETE CASCADE
);
</code></pre>
<h2 id="Домашнє-завдання-1"><a class="header" href="#Домашнє-завдання-1">Домашнє завдання:</a></h2>
<ol>
<li>Практикуємо все, що пройдено на уроці.</li>
<li>Переписати базу даних фільмів (із таблицями акторів, фільмів, режисерів), додавши <code>many-to-many</code> звʼязки</li>
<li>Створити базу даних студенти-групи-викладачі-кафедри (students-groups-teachers-departments).  Заповнити даними:</li>
</ol>
<pre><code class="language-sql">INSERT INTO departments (name) VALUES
('Computer Science'),
('Mathematics'),
('Physics');

INSERT INTO teachers (first_name, last_name, department_id) VALUES
('John', 'Doe', 1),
('Jane', 'Smith', 2),
('Robert', 'Johnson', 3),
('Emily', 'Williams', 1),
('Michael', 'Brown', 2);

INSERT INTO groups (name, department_id) VALUES
('CS50', 1),
('Math101', 2),
('Phys101', 3),
('CS101', 1);

INSERT INTO students (first_name, last_name, group_id) VALUES
('Alice', 'Johnson', 1),
('Bob', 'Smith', 2),
('Charlie', 'Williams', 3),
('David', 'Brown', 1),
('Eva', 'Davis', 2),
('Frank', 'Miller', 3),
('Grace', 'Jones', 4),
('Henry', 'Anderson', 1),
('Ivy', 'Moore', 2),
('Jack', 'Taylor', 3),
('Kate', 'White', 4),
('Leo', 'Martin', 1),
('Mia', 'Young', 2),
('Noah', 'Lee', 3),
('Olivia', 'Harris', 4),
('Paul', 'Clark', 1),
('Quinn', 'Evans', 2),
('Ryan', 'Wright', 3),
('Sophia', 'Walker', 4),
('Tyler', 'Hill', 1);
</code></pre>
<p>Зробити наступні запити:</p>
<ol>
<li>Вивести ім’я та прізвище студентів разом із назвами їх груп</li>
<li>Отримати список викладачів та назви кафедр, на яких вони працюють</li>
<li>Вивести кількість студентів у кожній групі</li>
<li>Вивести назву кафедри, імʼя та прізвище викладача, назву групи, імʼя та прізвище студента для викладачів із прізвищем Smith, Williams та Johnson, відсортувати за групою на прізвищем студента. Застосувати JOIN для з’єднання даних з усіх чотирьох таблиць на основі відповідних зовнішніх ключів.</li>
</ol>
<h2 id="Література-та-Корисні-посилання"><a class="header" href="#Література-та-Корисні-посилання">Література та Корисні посилання</a></h2>
<ol>
<li><a href="https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-foreign-key/">Introduction to PostgreSQL Foreign Key Constraint</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p><a href="db/13-postgresql-acid-normalization.excalidraw.html">13-postgresql-acid-normalization.excalidraw</a></p>
<h1 id="posgresql-acid-Нормальні-форми-бази-даних"><a class="header" href="#posgresql-acid-Нормальні-форми-бази-даних">PosgreSQL. ACID, Нормальні форми бази даних</a></h1>
<h1 id="Зміст-2"><a class="header" href="#Зміст-2">Зміст</a></h1>
<ul>
<li><a href="db/13-postgresql-acid-normalization.html#acid">ACID</a></li>
<li><a href="db/13-postgresql-acid-normalization.html#%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%8F-%D0%B1%D0%B0%D0%B7-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85">Нормалізація баз даних</a></li>
<li><a href="db/13-postgresql-acid-normalization.html#%D0%9B%D1%96%D1%82%D0%B5%D1%80%D0%B0%D1%82%D1%83%D1%80%D0%B0">Література</a></li>
</ul>
<h2 id="acid"><a class="header" href="#acid">ACID</a></h2>
<p><strong>ACID</strong> (англ. <em><strong>Atomicity, Consistency, Isolation, Durability</strong></em>) — це набір властивостей, що гарантують надійну роботу транзакцій бази даних: атомарність, узгодженість, ізольованість, довговічність.<br />
В контексті баз даних, послідовність операцій з базою даних, яка задовольняє властивостям ACID, можна розглядати як одну логічну операцію над даними. Така послідовність операцій називається транзакцією. Наприклад, переказ коштів з одного банківського рахунку на інший містить численні операції, але є єдиною транзакцією.</p>
<p>1983 року Андреа Рейтер і Тео Хардер ввели акронім ACID, ґрунтуючись на вимогах, які сформулював раніше науковець Джим Грей.<br />
<img src="db/attachments/Pasted%20image%2020240403103656.png" alt="" />
<a href="https://uk.wikipedia.org/wiki/ACID">https://uk.wikipedia.org/wiki/ACID</a></p>
<p><strong>Вимоги</strong></p>
<p>За Рейтером та Хардером, вимоги до цих чотирьох властивостей наступні:</p>
<p><strong>Atomicity — Атомарність</strong><br />
Транзакції часто містять в собі багато операцій. Атомарність гарантує, що жодна транзакція не буде виконана частково. Будуть або виконані всі операції, що беруть участь у транзакції, або не виконано жодної. Якщо протягом роботи однієї з операцій виникне помилка і операцію буде відхилено, то будуть відхилені також усі інші зміни, здійснені в межах транзакції. Система має бути атомарною у кожній ситуації, враховуючи відключення електроенергії, помилки та збої. Гарантія атомарності перешкоджає частковому оновленню бази даних, яке насправді може спричинити ще більші проблеми, аніж оновлення всієї бази в межах однієї транзакції.</p>
<p>Прикладом атомарної транзакції є переказ грошей з рахунку на рахунок, який проходить двома операціями: зняття грошей з першого рахунку та збереження їх на другому. Виконання цих операцій в атомарній транзакції забезпечує узгодженість даних бази, тобто гроші не віднімуться та не зарахуються, якщо одна з цих двох операцій зазнає невдачі.</p>
<p><strong>Consistency — Узгодженість</strong><br />
Відповідно до вимоги узгодженості, система має перебувати в узгодженому, несуперечливому стані до початку дії транзакції і по її завершенню. При цьому вона може перебувати в неузгодженому стані протягом виконання транзакції, проте ця неузгодженість не буде видимою за межами транзакції завдяки іншим властивостям — атомарності та ізольованості.</p>
<p>Таким чином, узгодженість гарантує інваріантивність бази даних: будь-які дані, записані в базу, мають відповідати усім визначеним правилам, враховуючи обмеження, каскади, тригери та будь-яку їхню комбінацію. Це запобігає пошкодженню бази даних некоректною транзакцією, але не гарантує правильність транзакції. Посилальну цілісність гарантує відношення унікального ключа до зовнішнього.</p>
<p>Наприклад, при переведенні коштів з рахунку на рахунок, кошти можна спочатку зняти з першого рахунку, після чого нараховувати на другий. Відповідно, після зняття коштів, але до їх нарахування система перебуває в неузгодженому стані: коштів немає на жодному з рахунків. Але після завершення транзакції повна сума перебуватиме на другому (або першому у випадку скасування транзакції) рахунку.</p>
<p><strong>Isolation — Ізольованість</strong><br />
Ізольованість означає, що жодні проміжні зміни не будуть видимі за межами транзакції аж до її завершення. Питання ізоляції стає актуальним при одночасній роботі багатьох транзакцій з тими самими даними. За цією вимогою, якщо дві транзакції намагатимуться змінити одні й ті самі дані, то одну з них буде відхилено або призупинено до завершення другої.</p>
<p><strong>Durability — Довговічність</strong><br />
Довговічність гарантує, що незалежно від інших проблем після відновлення працездатності системи результати завершених транзакцій будуть збережені. Іншими словами, якщо користувач отримав повідомлення про успішне завершення транзакції, то він може бути впевнений, що дані будуть збережені та відновлені у випадку збоїв.</p>
<h2 id="Нормалізація-баз-даних"><a class="header" href="#Нормалізація-баз-даних">Нормалізація баз даних</a></h2>
<p><img src="db/attachments/Pasted%20image%2020240403103707.png" alt="" /></p>
<p><strong>Нормалізація</strong> - це процес упорядкування даних у базі даних таким чином, щоб вона була вільна від надлишковості та залежності. Це допомагає усунути невідповідності та аномалії даних, тим самим покращуючи цілісність даних. Нормалізація - це набір правил або вказівки щодо розробки схеми бази даних таким чином, щоб уникнути дублювання даних, надмірності даних і неузгодженості даних.</p>
<p><img src="db/attachments/Pasted%20image%2020240403103732.png" alt="" /></p>
<p><a href="https://uk.wikipedia.org/wiki/%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%8F_%D0%B1%D0%B0%D0%B7_%D0%B4%D0%B0%D0%BD%D0%B8%D1%85">Нормальні форми</a></p>
<p>Існує кілька нормальних форм, кожна з яких будується на попередній, які скеровують нас у процесі нормалізації. Найпоширенішими звичайними формами є:</p>
<ul>
<li>
<p><em>Перша нормальна форма (1NF)</em>: кожен стовпець має містити атомарні (неподільні) значення. У таблиці не повинно бути повторюваних груп або масивів даних.</p>
</li>
<li>
<p><em>Друга нормальна форма (2NF):</em> кожен неключовий стовпець має функціонально залежати від усього первинного ключа. Іншими словами, кожен стовпець у таблиці має бути пов’язаний із первинним ключем, а не залежати від будь-яких інших неключових стовпців.</p>
</li>
<li>
<p><em>Третя нормальна форма (3NF)</em>: усі неключові стовпці мають залежати лише від первинного ключа, а не від будь-яких інших неключових стовпців. Це усуває транзитивні залежності.</p>
</li>
</ul>
<p>Нормалізація зменшує надлишковість даних і залежність, роблячи базу даних більш ефективною, гнучкою та масштабованою. Це також допомагає підтримувати узгодженість і точність даних, а також гарантує належну обробку оновлень і видалень.</p>
<h2 id="Література-1"><a class="header" href="#Література-1">Література</a></h2>
<ol>
<li><a href="https://javarush.com/ua/quests/lectures/ua.questhibernate.level17.lecture02">Нормальні форми бази даних</a></li>
<li><a href="https://edu-python-course.github.io/_build/html/uk/rdbms/normalization.html">https://edu-python-course.github.io/_build/html/uk/rdbms/normalization.html</a></li>
<li><a href="https://rdb.dp.ua/uk/chapter_03">Нормалізація відношень при проектуванні БД</a></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
